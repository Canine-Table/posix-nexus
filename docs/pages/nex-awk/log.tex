\nxSections{Logging Module}{1}

\nxSections{Signed Number Detection}{2}
\begin{NxCodeBox}{awk}{title={nx\_fd\_stderr(D)}}
function nx_fd_stderr(D)
{
		if (D) {
				gsub(/"/, "\\\"" D)
				system("printf \"" D "\" 1>&2")
		}
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={}]
	\nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
			{Purpose}/{Emit string \(D\) to standard error using shell printf},%
			{Escaping}/{Double quotes in \(D\) are escaped via \texttt{gsub}},%
			{Condition}/{Only executes if \(D\) is non-empty},%
			{Shell Invocation}/{Uses \texttt{system("printf ...")} for stderr emission},%
			{Edge Case}/{Newlines and shell metacharacters are passed verbatim—input must be trusted},%
			{Compliance}/{POSIX AWK compatible; no refactor required},%
			{Use Case}/{Diagnostic logging, error propagation, or stderr tracing in AWK scripts}
	}
\end{NxLightListBox}

\nxSections{ANSI Style Mapper}{2}

\begin{NxCodeBox}{awk}{title={\_\_nx\_ansi\_smap(D)}}
function __nx_ansi_smap(D,  c)
{
    if (D == "o") # overline
        return 53
    if (D == "O") # not overline
        return 55
    if (D != (c = tolower(D))) {
        D = c
        c = 20
    } else {
        c = 0
    }
    if (D == "n") # normal
        return "0"
    if (D == "b") # bold
        return c + 1
    if (D == "d") # dim
        return c + 2
    if (D == "i") # italic
        return c + 3
    if (D == "u") # underline
        return c + 4
    if (D == "f") # flash
        return c + 5
    if (D == "r") # reverse video
        return c + 7
    if (D == "h") # hide
        return c + 8
    if (D == "s") # strike
        return c + 9
    return 0
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={ANSI Style Mapper — The Style Glyph}]
    \nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
        {Purpose}/{Maps style code \(D\) to ANSI numeric value},%
        {Input}/{Single-character code \(D\); case-sensitive for overline variants},%
        {Brightness}/{Uppercase \(D\) triggers bright variant (adds 20)},%
        {Special Codes}/{\texttt{o}=overline (53), \texttt{O}=not overline (55)},%
        {Use Case}/{Style formatting for terminal output or ANSI escape generation}
    }
\end{NxLightListBox}

\begin{NxLightBox}[title={ANSI Style Code Map}]
    \begin{tabularx}{\textwidth}{|l|X|}
        \hline
        \textbf{Code} & \textbf{Mapped ANSI Value} \\
        \hline
        n & Normal (0) \\
        b & Bold (1) / Bright Bold (21) \\
        d & Dim (2) / Bright Dim (22) \\
        i & Italic (3) / Bright Italic (23) \\
        u & Underline (4) / Bright Underline (24) \\
        f & Flash (5) / Bright Flash (25) \\
        r & Reverse Video (7) / Bright Reverse (27) \\
        h & Hide (8) / Bright Hide (28) \\
        s & Strike (9) / Bright Strike (29) \\
        o & Overline (53) \\
        O & Not Overline (55) \\
        \hline
        \multicolumn{2}{|l|}{Add 20 for bright variant (uppercase \(D\))} \\
        \hline
    \end{tabularx}
\end{NxLightBox}

\nxSections{ANSI Color Mapper}{2}

\begin{NxCodeBox}{awk}{title={\_\_nx\_ansi\_cmap(D1, D2)}}
function __nx_ansi_cmap(D1, D2,     c)
{
    if (D2 == "<")
        c = 10
    else
        c = 0
    if ((D2 = tolower(D1)) == "c")
        return c + 39
    if (D2 == "r")
        return c + 38
    if (D1 != D2)
        c += 60
    if (D2 == "b")
        return c + 30
    if (D2 == "e")
        return c + 31
    if (D2 == "s")
        return c + 32
    if (D2 == "w")
        return c + 33
    if (D2 == "i")
        return c + 34
    if (D2 == "d")
        return c + 35
    if (D2 == "a")
        return c + 36
    if (D2 == "l")
        return c + 37
    return 0
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={ANSI Color Mapper — The Chromatic Glyph}]
    \nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
        {Purpose}/{Maps color code \(D1\) to ANSI numeric value},%
        {Foreground}/{Use \texttt{>} in \(D2\) to select foreground mode},%
        {Background}/{Use \texttt{<} in \(D2\) to select background mode},%
        {Brightness}/{Uppercase \(D1\) triggers bright variant (adds 60)},%
        {Normalization}/{Lowercase \(D1\) yields normal intensity},%
        {Special Codes}/{\texttt{c}=default (39), \texttt{r}=reset (38)},%
        {Use Case}/{Color formatting for terminal output or ANSI escape generation}
    }
\end{NxLightListBox}

\begin{NxLightBox}[title={ANSI Color Code Map}]
    \begin{tabularx}{\textwidth}{|l|X|}
        \hline
        \textbf{Code} & \textbf{Base ANSI Value} \\
        \hline
        b & Black (30) / Bright Black (90) \\
        e & Red (31) / Bright Red (91) \\
        s & Green (32) / Bright Green (92) \\
        w & Yellow (33) / Bright Yellow (93) \\
        i & Blue (34) / Bright Blue (94) \\
        d & Magenta (35) / Bright Magenta (95) \\
        a & Cyan (36) / Bright Cyan (96) \\
        l & Light gray (37) / Bright White (97) \\
        c & Default color (39) \\
        r & Reset foreground (38) \\
        \hline
        \multicolumn{2}{|l|}{Add 10 for background mode (\texttt{<})} \\
        \multicolumn{2}{|l|}{Add 60 for bright variant (uppercase \(D1\))} \\
        \hline
    \end{tabularx}
\end{NxLightBox}

\nxSections{ANSI Print Emitter}{2}
\begin{NxCodeBox}{awk}{title={nx\_ansi\_print(D, B)}}
function nx_ansi_print(D, B,    stk, ansi, args)
{
    # D has no more use, lets store the index counter in it
    if ((D = split(D, args, "<nx:null/>")) < 2) {
        delete args
        return -1
    }
    args[1] = split("2" args[1], ansi, "")
    ansi[0] = args[1]

    args[0] = D # varargs count
    args[1] = 2 # varargs index
    D = ""

    stk[0] = 2
    stk[1] = ">"
    stk[2] = "\0"
    stk[3] = "<nx:false/>"
    do {
        if (ansi[ansi[1]] ~ /[<>_\0]/) {
            stk[1] = ansi[ansi[1]]
        } else if (ansi[ansi[1]] == "^") {
            stk[2] = __nx_ansi_pmap(ansi[++ansi[1]])
        } else if (ansi[ansi[1]] == "%") {
            D = D __nx_if(stk[3] == "<nx:false/>", "", "m") __nx_if(stk[1] == "\0" || stk[2] == "\0", "", "[" stk[2] "]\x1b[37m: ") __nx_if(stk[4], stk[4] "m", "") args[args[1]++]
            stk[3] = "<nx:false/>"
            stk[4] = ""
        } else {
            if (stk[1] ~ /[<>_]/) {
                stk[5] = __nx_if(stk[3] == "<nx:false/>", "\x1b[", ";") __nx_if(stk[1] == "_", __nx_ansi_smap(ansi[ansi[1]]), __nx_ansi_cmap(ansi[ansi[1]], stk[1]))
                D = D stk[5]
                stk[4] = stk[4] stk[5]
                stk[3] = "<nx:true/>"
            } else {
                D = D __nx_if(stk[3] == "<nx:false/>", "", "m") ansi[ansi[1]]
                stk[3] = "<nx:false/>"
            }
        }
    } while (args[1] <= args[0] && ++ansi[1] <= ansi[0])
    if (B != "<nx:true/>") {
        nx_fd_stderr(D "\x1b[0m")
        D = args[1]
    }
    delete args
    delete stk
    delete ansi
    return D
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={ANSI Print Emitter — The Render Glyph}]
    \nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
        {Purpose}/{Renders styled output using ANSI sequences and symbolic glyphs},%
        {Input}/{\(D\): markup string with embedded style codes and placeholders; \(B\): optional suppress flag},%
        {Markup}/{Uses \texttt{<nx:null/>} as delimiter for varargs; style codes include \texttt{<}, \texttt{>}, \texttt{\_}},%
        {Glyphs}/{Symbolic glyphs injected via \texttt{\^} and mapped by \texttt{\_\_nx\_ansi\_pmap}},%
        {Substitution}/{\texttt{\%} triggers vararg injection with optional prefix and style context},%
        {Style Codes}/{Resolved via \texttt{\_\_nx\_ansi\_smap} or \texttt{\_\_nx\_ansi\_cmap} depending on mode},%
        {Output}/{Emitted to stderr unless \(B = \texttt{<nx:true/>}\); resets with \texttt{\textbackslash x1b[0m}},%
        {Use Case}/{Diagnostic rendering, styled logging, or symbolic output in AWK scripts}
    }
\end{NxLightListBox}

\nxSections{ANSI Pictographic Mapper}{2}

\begin{NxCodeBox}{awk}{title={\_\_nx\_ansi\_pmap(D)}}
function __nx_ansi_pmap(D)
{
    if (D == "b") { # emphasis
        D = "#"
    } else if (D == "B") { # pipeline
        D = "|"
    } else if (D == "e") { # minor error
        D = "x"
    } else if (D == "E") { # critical error needs attention like yesterday
        D = "X"
    } else if (D == "s") { # success
        D = "v"
    } else if (D == "S") { # great success
        D = "V"
    } else if (D == "w") { # warning
        D = "!"
    } else if (D == "W") { # warning but not sure
        D = "?"
    } else if (D == "d") { # debug
        D = "*"
    } else if (D == "D") { # trace
        D = ">"
    } else if (D == "i") { # info
        D = "i"
    } else if (D == "I") { # verbose
        D = "."
    } else if (D == "l") { # log
        D = "%"
    } else if (D == "L") { # detailed log
        D = "$"
    } else if (D == "a") { # alert
        D = "@"
    } else if (D == "A") { # more info alert
        D = "&"
    } else {
        return "\0"
    }
    return nx_ansi_print("_uir%_UIR%<nx:null/>" D "<nx:null/>", "<nx:true/>")
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={ANSI Pictographic Mapper — The Symbol Glyph}]
    \nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
        {Purpose}/{Maps symbolic code \(D\) to a printable glyph},%
        {Input}/{Single-character code \(D\); case-sensitive},%
        {Fallback}/{Returns \texttt{"\textbackslash0"} if code is unrecognized},%
        {Rendering}/{Delegates to \texttt{nx\_ansi\_print(...)} for styled output},%
        {Use Case}/{Diagnostic symbols, log annotations, or status glyphs}
    }
\end{NxLightListBox}

\begin{NxLightBox}[title={ANSI Symbol Code Map}]
    \begin{tabularx}{\textwidth}{|l|X|}
        \hline
        \textbf{Code} & \textbf{Mapped Glyph} \\
        \hline
        b & \# (emphasis) \\
        B & \textbar{} (pipeline) \\
        e & x (minor error) \\
        E & X (critical error) \\
        s & v (success) \\
        S & V (great success) \\
        w & ! (warning) \\
        W & ? (uncertain warning) \\
        d & * (debug) \\
        D & > (trace) \\
        i & i (info) \\
        I & . (verbose) \\
        l & \% (log) \\
        L & \$ (detailed log) \\
        a & @ (alert) \\
        A & \& (info alert) \\
        \hline
    \end{tabularx}
\end{NxLightBox}

