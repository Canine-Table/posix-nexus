\nxSections{I/O Modules}{1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nxSections{File Readability Sentinel}{2}

\begin{NxCodeBox}{awk}{phantomlabel={func:nx_is_file},
	title={\textbf{nx\_is\_file Arguments}
	\begin{NxDarkList}
		\nxEachArw{CodePrimary}{Tertiary}{1}{%
			{D}/{Candidate file path to probe},%
			{B}/{Boolean or mode flag controlling strictness of the readability test}%
		}
	\end{NxDarkList}
}}
function nx_is_file(D, B)
\end{NxCodeBox}

\begin{NxLightListBox}[title={File Readability Sentinel — The Probe Glyph}]
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{Purpose}/{Determine whether a given path \nxSQ{D} refers to a readable file, with strict or permissive content requirements depending on \nxSQ{B}},%
		{Input}/{\nxSQ{D} is the file to test; \nxSQ{B} selects the probe threshold:
			\begin{NxLightList}
				\nxEachArw{CodeSuccess}{Secondary}{1}{%
					{$B = ""$}/{Strict mode: \texttt{getline < D} must return \textbf{> 0}, meaning the file is readable \emph{and contains at least one line of content}},%
					{$B \neq ""$}/{Permissive mode: \texttt{getline < D} must return \textbf{> -1}, meaning the file is readable even if it is \emph{empty}}%
				}
			\end{NxLightList}},%
		{Mechanism}/{\nxLnArcBox[]{\nxListDark}\begin{NxLightList}
			\nxEachItem{ArrowDark}{%
				{Empty path}/{If \nxSQ{D} is empty, immediately return \nxSQ{0}},%
				{Probe}/{Attempt \texttt{getline < D} using the threshold determined by \nxSQ{B}},%
				{Close}/{If the probe succeeds, close the stream handle},%
				{Failure}/{If the probe fails the threshold, return \nxSQ{0}},%
				{Success}/{Otherwise return \nxSQ{1}}%
			}
		\end{NxLightList}},%
		{Output}/{Returns \nxSQ{1} if the file is readable under the chosen mode, \nxSQ{0} otherwise},%
		{Use Case}/{Foundational predicate for all file-identity and include-expansion rituals; ensures that only real, readable files (optionally non-empty) enter the semantic universe}%
	}
\end{NxLightListBox}

\nxSections{Examples}{3}

\begin{NxCodeBox}{awk}{title={\textbf{Strict readability check (non-empty file required)}
	\begin{NxDarkList}
		\nxEachArw{CodePrimary}{Tertiary}{1}{%
			{State}/{\texttt{D=\nxSQ{config.cfg}}, \texttt{B=\nxSQ{}} (strict mode)},%
			{Operation}/{Probe succeeds only if \nxSQ{config.cfg} is readable \emph{and contains at least one line}},%
			{Expected Result}/{Returns \nxSQ{1} for non-empty readable files; \nxSQ{0} for empty or unreadable files}
		}
	\end{NxDarkList}
}}
nx_is_file("config.cfg", "")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Permissive readability check (empty file allowed)}
	\begin{NxDarkList}
		\nxEachArw{CodePrimary}{Tertiary}{1}{%
			{State}/{\texttt{D=\nxSQ{empty.log}}, \texttt{B=\nxSQ{1}} (permissive mode)},%
			{Operation}/{Probe succeeds if \nxSQ{empty.log} is readable, even if it contains no content},%
			{Expected Result}/{Returns \nxSQ{1} for readable files regardless of content; \nxSQ{0} only if unreadable}
		}
	\end{NxDarkList}
}}
nx_is_file("empty.log", 1)
\end{NxCodeBox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nxSections{Path Normalization Conductor}{2}

\begin{NxCodeBox}{awk}{phantomlabel={func:nx_file_path},
	title={\textbf{nx\_file\_path Arguments}
	\begin{NxDarkList}
		\nxEachArw{CodePrimary}{Tertiary}{1}{%
			{D1}/{Input path to normalize or dissect},%
			{B}/{Boolean or mode flag selecting which component to return},%
			{D2}/{Directory separator (default \nxDQ{/})},%
			{V}/{Prefix-expansion map for \nxSQ{NX\_*:/}, \nxSQ{\textasciitilde/}, and \nxSQ{-/}}%
		}
	\end{NxDarkList}
}}
function nx_file_path(D1, B, D2, V)
\end{NxCodeBox}

\begin{NxLightListBox}[title={Path Normalization Conductor — The Dissection Glyph}]
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{Purpose}/{Normalize a file path, expand prefix sigils, collapse redundant separators, and optionally extract basename or directory components depending on \nxSQ{B}},%
		{Input}/{\nxSQ{D1} is the raw path; \nxSQ{B} selects the return mode; \nxSQ{D2} is the directory separator; \nxSQ{V} holds prefix expansions:
			\begin{NxLightList}
				\nxEachArw{CodeSuccess}{Secondary}{1}{%
					{$B = ""$}/{Return the \emph{basename} (final component)},%
					{$B = 0$}/{Return the \emph{full normalized path}},%
					{$B \neq ""$}/{Return the \emph{directory path} (parent directory)}%
				}
			\end{NxLightList}},%
		{Mechanism}/{\nxLnArcBox[]{\nxListDark}\begin{NxLightList}
			\nxEachItem{ArrowDark}{%
				{Prefix expansion}/{If \nxSQ{D1} begins with \nxSQ{-/}, \nxSQ{\textasciitilde/}, or \nxSQ{NX\_*:/}, expand using \nxSQ{V} (environment-derived prefix map)},%
				{Separator collapse}/{Reduce repeated separators \nxSQ{D2+} to a single \nxSQ{D2}},%
				{Trailing cleanup}/{Remove trailing separators unless the path is root},%
				{Basename extraction}/{If $B = ""$, strip directory prefix and return final component},%
				{Directory extraction}/{If $B \neq ""$, strip basename and return parent directory},%
				{Full path}/{If $B = 0$, return the normalized path unchanged}%
			}
		\end{NxLightList}},%
		{Output}/{A normalized path, basename, or directory path depending on \nxSQ{B}},%
		{Use Case}/{Core utility for all file-identity and include-expansion rituals; ensures consistent path semantics across prefix expansions, directory sweeps, and file lookups}%
	}
\end{NxLightListBox}

\nxSections{Examples}{3}

\begin{NxCodeBox}{awk}{title={\textbf{Extract basename (strict basename mode)}%
	\begin{NxDarkList}
		\nxEachArw{CodePrimary}{Tertiary}{1}{%
			{State}/{\texttt{D1=\nxSQ{/usr/local/bin/awk}}, \texttt{B=\nxSQ{}}},%
			{Operation}/{Return only the final component},%
			{Expected Result}/{\nxSQ{awk}}
		}
	\end{NxDarkList}
}}
nx_file_path("/usr/local/bin/awk", "", "/")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Return full normalized path}}
	\begin{NxDarkList}
		\nxEachArw{CodePrimary}{Tertiary}{1}{%
			{State}/{\texttt{D1=\nxSQ{~/projects///nx}}, \texttt{B=0}},%
			{Operation}/{Expand prefix, collapse separators, return full path},%
			{Expected Result}/{Normalized absolute path to \nxSQ{nx}}
		}
	\end{NxDarkList}
}
nx_file_path("~/projects///nx", 0, "/", V)
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Extract directory path (parent directory)}}
	\begin{NxDarkList}
		\nxEachArw{CodePrimary}{Tertiary}{1}{%
			{State}/{\texttt{D1=\nxSQ{NX\_C:/config/main.cfg}}, \texttt{B=1}},%
			{Operation}/{Expand \nxSQ{NX\_C:/}, strip basename, return directory},%
			{Expected Result}/{Parent directory of \nxSQ{main.cfg}}
		}
	\end{NxDarkList}
}
nx_file_path("NX_C:/config/main.cfg", 1, "/", V)
\end{NxCodeBox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nxSections{Extension Sweep Conductor}{2}

\begin{NxCodeBox}{awk}{phantomlabel={func:nx_file_path_expand},
	title={\textbf{nx\_file\_path\_expand Arguments}
	\begin{NxDarkList}
		\nxEachArw{CodePrimary}{Tertiary}{1}{%
			{D1}/{Primary prefix path used when constructing candidate files},%
			{D2}/{Secondary prefix path used for alternate construction},%
			{D3}/{Basename to sweep for extensions},%
			{D4}/{Extension-separator regex (default \nxSQ{[.]})},%
			{D5}/{Directory separator (default \nxDQ{/})},%
			{V1}/{Parallel-array registry for file identity triples},%
			{V2}/{Prefix-expansion map for \nxSQ{NX\_*:/}, \nxSQ{\textasciitilde/}, and \nxSQ{-/}},%
			{B1}/{Boolean/mode flag selecting sweep strategy},%
			{B2}/{Boolean/mode flag passed to \texttt{nx\_is\_file}}%
		}
	\end{NxDarkList}
}}
function nx_file_path_expand(D1, D2, D3, D4, D5, V1, V2, B1, B2)
\end{NxCodeBox}

\begin{NxLightListBox}[title={Extension Sweep Conductor — The Expansion Glyph}]
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{Purpose}/{Perform an extension-sweep over a basename \nxSQ{D3}, generating candidate paths by peeling extensions and testing each candidate with \texttt{nx\_file\_store}},%
		{Input}/{\nxSQ{D1} and \nxSQ{D2} are prefix paths; \nxSQ{D3} is the basename; \nxSQ{D4} and \nxSQ{D5} define separators; \nxSQ{V1} and \nxSQ{V2} support file resolution; \nxSQ{B1} and \nxSQ{B2} control sweep and readability modes:
			\begin{NxLightList}
				\nxEachArw{CodeSuccess}{Secondary}{1}{%
					{$B1$}/{Sweep mode: determines whether extension-peeling is active},%
					{$B2$}/{Readability mode passed to \texttt{nx\_is\_file}}%
				}
			\end{NxLightList}},%
		{Mechanism}/{\nxLnArcBox[]{\nxListDark}\begin{NxLightList}
			\nxEachItem{ArrowDark}{%
				{Reverse scan}/{Reverse \nxSQ{D3} to locate extension boundaries using \nxSQ{D4}},%
				{Peel extension}/{Each match shortens the basename and accumulates peeled extensions into \nxSQ{ext}},%
				{Construct candidates}/{For each peel, construct:
					\begin{NxLightList}
						\nxEachArw{CodeSuccess}{Secondary}{1}{%
							{Candidate 1}/{\nxSQ{D1 ext D5 bs}},%
							{Candidate 2}/{\nxSQ{D2 ext D5 D3}}%
						}
					\end{NxLightList}},%
				{Probe}/{Call \texttt{nx\_file\_store} on each candidate; success halts the sweep},%
				{Termination}/{Stop when a readable file is found or no more extension boundaries remain}%
			}
		\end{NxLightList}},%
		{Output}/{Returns \nxSQ{1} if any candidate path resolves to a readable file; \nxSQ{-1} otherwise},%
		{Use Case}/{Used by \texttt{nx\_file\_store} when fallback mode requests extension-peeling; enables discovery of files such as \nxSQ{config.json}, \nxSQ{config.yaml}, \nxSQ{config.conf} by sweeping suffixes of \nxSQ{config}}%
	}
\end{NxLightListBox}

\nxSections{Examples}{3}

\begin{NxCodeBox}{awk}{title={\textbf{Sweep for alternate extensions}}
	\begin{NxDarkList}
		\nxEachArw{CodePrimary}{Tertiary}{1}{%
			{State}/{Basename \nxSQ{config.json}, prefixes \nxSQ{D1=\nxSQ{/etc/}}, \nxSQ{D2=\nxSQ{/usr/local/etc/}}},%
			{Operation}/{Peel \nxSQ{.json}, test \nxSQ{config}, then test \nxSQ{config.json} under both prefixes},%
			{Expected Result}/{Returns \nxSQ{1} if any candidate resolves to a readable file}
		}
	\end{NxDarkList}
}}
nx_file_path_expand("/etc/", "/usr/local/etc/", "config.json", "[.]", "/", V1, V2, 1, "")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Multiple extension layers (e.g., \nxSQ{.tar.gz})}
	\begin{NxDarkList}
		\nxEachArw{CodePrimary}{Tertiary}{1}{%
			{State}/{Basename \nxSQ{archive.tar.gz}},%
			{Operation}/{Peel \nxSQ{.gz}, then \nxSQ{.tar}, constructing candidates at each stage},%
			{Expected Result}/{First readable candidate halts the sweep and returns \nxSQ{1}}
		}
	\end{NxDarkList}
}}
nx_file_path_expand("/data/", "/backup/", "archive.tar.gz", "[.]", "/", V1, V2, 1, 1)
\end{NxCodeBox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nxSections{File Identity Conductor}{2}

\begin{NxCodeBox}{awk}{phantomlabel={func:nx_file_store},
	title={\textbf{nx\_file\_store Arguments}
	\begin{NxDarkList}
		\nxEachArw{CodePrimary}{Tertiary}{1}{%
			{V1}/{Parallel-array registry storing file identity triples},%
			{D1}/{Input file name (basename or relative path)},%
			{D2}/{Optional prefix path to search under},%
			{V2}/{Prefix-expansion map for \nxSQ{NX\_*:/}, \nxSQ{\textasciitilde/}, and \nxSQ{-/}},%
			{D3}/{Directory separator (default \nxDQ{/})},%
			{B1}/{Boolean/mode flag selecting fallback strategy},%
			{B2}/{Boolean/mode flag passed to \texttt{nx\_is\_file}},%
			{D4}/{Extension-separator regex used by \texttt{nx\_file\_path\_expand}}%
		}
	\end{NxDarkList}
}}
function nx_file_store(V1, D1, D2, V2, D3, B1, B2, D4)
\end{NxCodeBox}

\begin{NxLightListBox}[title={File Identity Conductor — The Triple Glyph}]
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{Purpose}/{Resolve a file path, verify readability, and register its identity triple (real path, directory path, basename) into a bijective parallel-array registry},%
		{Input}/{\nxSQ{D1} is the candidate file; \nxSQ{D2} is an optional search prefix; \nxSQ{V2} holds prefix expansions; \nxSQ{B1} and \nxSQ{B2} control fallback and readability modes:
			\begin{NxLightList}
				\nxEachArw{CodeSuccess}{Secondary}{1}{%
					{$B1 = 0$}/{No fallback: only direct path resolution attempted},%
					{$B1 = 1$}/{Extension-sweep fallback via \texttt{nx\_file\_path\_expand}},%
					{$B1 = 2$}/{Directory-sweep fallback across known directories in \nxSQ{V1}},%
					{$B1 = 3$}/{Combined sweep: extension first, then directory},%
					{$B2$}/{Strict/permissive readability mode passed to \texttt{nx\_is\_file}}%
				}
			\end{NxLightList}},%
		{Mechanism}/{\nxLnArcBox[]{\nxListDark}\begin{NxLightList}
			\nxEachItem{ArrowDark}{%
				{Normalize paths}/{Compute:
					\begin{NxLightList}
						\nxEachArw{CodeSuccess}{Secondary}{1}{%
							{rlp}/{Resolved lookup path: \nxSQ{D2 + D1} normalized},%
							{orlp}/{Original path: \nxSQ{D1} normalized},%
							{bs}/{Basename extracted from \nxSQ{D1}}%
						}
					\end{NxLightList}},%
				{Direct probe}/{Test \nxSQ{rlp} and \nxSQ{orlp} with \texttt{nx\_is\_file} under mode \nxSQ{B2}},%
				{Directory sweep}/{If \nxSQ{B1 = 2}, iterate directories stored in \nxSQ{V1} to locate a readable file},%
				{Extension sweep}/{If \nxSQ{B1 = 1} or \nxSQ{3}, call \texttt{nx\_file\_path\_expand} to peel extensions and test candidates},%
				{Identity triple}/{Once a readable file is found:
					\begin{NxLightList}
						\nxEachArw{CodeSuccess}{Secondary}{1}{%
							{Real Path}/{Canonical resolved path},%
							{Directory Path}/{Parent directory},%
							{Basename}/{Final component of the file name}%
						}
					\end{NxLightList}},%
				{Registry insertion}/{Insert each component into \nxSQ{V1} using \texttt{nx\_bijective} and \texttt{nx\_parr\_stk}},%
				{Return code}/{\nxSQ{1} if newly registered, \nxSQ{0} if already known, \nxSQ{-1} on failure}%
			}
		\end{NxLightList}}%
	}
\end{NxLightListBox}

\begin{NxLightListBox}
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{Output}/{Returns \nxSQ{1} for a new identity triple, \nxSQ{0} if already present, \nxSQ{-1} if no readable file could be resolved},%
		{Use Case}/{Foundation of all file-merge, overlay, and include-expansion systems; ensures every file entering the semantic universe has a stable, bijective identity triple}%
	}
\end{NxLightListBox}

\nxSections{Examples}{3}

\begin{NxCodeBox}{awk}{title={\textbf{Direct resolution (no fallback)}
	\begin{NxDarkList}
		\nxEachArw{CodePrimary}{Tertiary}{1}{%
			{State}/{\texttt{D1=\nxSQ{config}}, \texttt{D2=\nxSQ{NX\_C:/}}, \texttt{B1=0}},%
			{Operation}/{Resolve \nxSQ{NX\_C:/config} and register its identity triple},%
			{Expected Result}/{\nxSQ{1} if new, \nxSQ{0} if already known}
		}
	\end{NxDarkList}
}}
nx_file_store(V1, "config", "NX_C:/", V2, "/", 0, "", "[.]")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Extension-sweep fallback}
	\begin{NxDarkList}
		\nxEachArw{CodePrimary}{Tertiary}{1}{%
			{State}/{\texttt{D1=\nxSQ{theme}}, \texttt{B1=1}},%
			{Operation}/{Try \nxSQ{theme}, then \nxSQ{theme.*} by peeling extensions},%
			{Expected Result}/{First readable candidate registered}
		}
	\end{NxDarkList}
}}
nx_file_store(V1, "theme", "", V2, "/", 1, "", "[.]")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Directory-sweep fallback}
	\begin{NxDarkList}
		\nxEachArw{CodePrimary}{Tertiary}{1}{%
			{State}/{\texttt{D1=\nxSQ{settings.cfg}}, \texttt{B1=2}},%
			{Operation}/{Search directories already registered in \nxSQ{V1}},%
			{Expected Result}/{First readable match registered}
		}
	\end{NxDarkList}
}}
nx_file_store(V1, "settings.cfg", "", V2, "/", 2, "", "[.]")
\end{NxCodeBox}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nxSections{Include Directive Conductor}{2}

\begin{NxCodeBox}{awk}{phantomlabel={func:nx_file_merge},
	title={\textbf{nx\_file\_merge Arguments}
	\begin{NxDarkList}
		\nxEachArw{CodePrimary}{Tertiary}{1}{%
			{D1}/{Root file name or input stream to expand},%
			{D2}/{File-exclusion list; omit these if encountered after a directive},%
			{D3}/{Separator used to split the delimiter specification \nxSQ{D4}},%
			{D4}/{Five-field delimiter specification:
				\begin{NxDarkList}
					\nxEachArw{CodeSuccess}{Tertiary}{1}{%
						{[1]}/{File-exclusion separator},%
						{[2]}/{Directive sigil},%
						{[3]}/{Directory separator},%
						{[4]}/{File-extension separator},%
						{[5]}/{Directive name}%
					}
				\end{NxDarkList}},%
			{B}/{Boolean/mode flag passed to \texttt{nx\_file\_store}},%
			{N}/{Verbosity and diagnostic level}%
		}
	\end{NxDarkList}
}}
function nx_file_merge(D1, D2, D3, D4, B, N)
\end{NxCodeBox}

\begin{NxLightListBox}[title={Include Directive Conductor — The Expansion Glyph}]
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{Purpose}/{Traverse a root file, detect include directives, recursively load referenced files, and emit a fully expanded DFS-ordered text stream with cycle prevention and customizable directive syntax},%
		{Input}/{\nxSQ{D1} is the entry file; \nxSQ{D2} lists files to omit; \nxSQ{D3} and \nxSQ{D4} define directive and path delimiters; \nxSQ{B} controls fallback behavior in \texttt{nx\_file\_store}; \nxSQ{N} controls diagnostics},%
		{Mechanism}/{\nxLnArcBox[]{\nxListDark}\begin{NxLightList}
			\nxEachItem{ArrowDark}{%
				{Parse delimiter specification}/{Split \nxSQ{D4} using \nxSQ{D3}; extract file-exclusion separator, directive sigil, directory separator, extension separator, and directive name; warn if more than five fields are provided},%
				{Validate delimiters}/{Each delimiter is checked via \texttt{nx\_delim\_sep} to ensure it is safe and unambiguous},%
				{Load root file}/{Resolve and register the root file using \texttt{nx\_file\_store}; abort if unreadable},%
				{Apply exclusion list}/{Split \nxSQ{D2} using the exclusion separator; resolve each excluded file and update the drop-prefix to prevent re-inclusion},%
				{Construct directive regex}/{Build patterns matching the directive sigil, directive name, and filename argument},%
				{Recursive expansion}/{\nxSQ{stk[]} accumulates text fragments; \nxSQ{trk[]} tracks pending include files; each include spawns a new DFS branch},%
				{Directive handling}/{If a line matches the directive:
					\begin{NxLightList}
						\nxEachArw{CodeSuccess}{Success}{1}{%
							{Prefix}/{Extract text before the directive},%
							{Argument}/{Extract filename argument and attempt resolution via \texttt{nx\_file\_store}},%
							{Branch}/{If new file, push prefix and queue file for DFS expansion; otherwise emit prefix only}%
						}
					\end{NxLightList}},%
				{Non-directive lines}/{Preserved verbatim unless empty or whitespace-only},%
				{DFS flattening}/{After all recursive expansions, \texttt{nx\_dfs(stk)} linearizes the include tree into a stable output order},%
				{Emission}/{Final merged text is printed in DFS order, preserving all non-empty fragments}%
			}
		\end{NxLightList}}%
	}
\end{NxLightListBox}

\begin{NxLightListBox}
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{Output}/{Prints a fully expanded text stream with all include directives resolved; returns \nxSQ{-1} on delimiter or file-resolution failure},%
		{Use Case}/{Core of the Nx preprocessor: enables modular documents, chained configuration files, recursive overlays, and controlled include semantics with cycle prevention and customizable syntax}%
	}
\end{NxLightListBox}

\nxSections{Examples}{3}

\begin{NxCodeBox}{awk}{title={\textbf{Basic include expansion}
	\begin{NxDarkList}
		\nxEachArw{CodePrimary}{Tertiary}{1}{%
			{State}/{\texttt{D1=\nxSQ{main.txt}}, directive sigil \nxSQ{\#}, directive name \nxSQ{nx\_include}},%
			{Operation}/{Expand all \nxSQ{\#nx\_include file} directives recursively},%
			{Expected Result}/{Merged output printed with all includes resolved in DFS order}
		}
	\end{NxDarkList}
}}
nx_file_merge("main.txt", "", ",", "#,/,.,nx_include", 1, 1)
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Exclude specific files during expansion}
	\begin{NxDarkList}
		\nxEachArw{CodePrimary}{Tertiary}{1}{%
			{State}/{\texttt{D2=\nxSQ{secret.cfg,debug.cfg}}},%
			{Operation}/{If encountered after a directive, these files are ignored},%
			{Expected Result}/{Expansion proceeds without merging excluded files}
		}
	\end{NxDarkList}
}}
nx_file_merge("main.txt", "secret.cfg,debug.cfg", ",", "#,/,.,nx_include", 1, 1)
\end{NxCodeBox}

