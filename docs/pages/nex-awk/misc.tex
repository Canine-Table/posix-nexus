\nxSections{Miscellaneous Module}{1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nxSections{Character Classifiers}{2}

\begin{NxCodeBox}{awk}{title={nx\_is\_space(D)}}
function nx_is_space(D) { return D ~ /[ \t\n\f\r\v\b]/ }
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={nx\_is\_upper(D)}}
function nx_is_upper(D) { return D ~ /[A-Z]/ }
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={nx\_is\_lower(D)}}
function nx_is_lower(D) { return D ~ /[a-z]/ }
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={nx\_is\_alpha(D)}}
function nx_is_alpha(D) { return nx_is_lower(D) || nx_is_upper(D) }
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={nx\_is\_digit(D)}}
function nx_is_digit(D) { return D ~ /[0-9]/ }
\end{NxCodeBox}

\begin{NxLightListBox}[title={Character Classifiers — The Glyph Filters}]
		\nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
				{nx\_is\_space}/{Checks for whitespace characters},%
				{nx\_is\_upper}/{Checks for uppercase letters},%
				{nx\_is\_lower}/{Checks for lowercase letters},%
				{nx\_is\_alpha}/{Checks for alphabetic characters},%
				{nx\_is\_digit}/{Checks for numeric digits}
		}
\end{NxLightListBox}

\nxSections{File Presence Checker}{2}

\begin{NxCodeBox}{awk}{title={nx\_is\_file(D)}}
function nx_is_file(D)
{
		if ((getline < D) > 0)
				close(D)
		else
				return 0
		return 1
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={File Presence Checker — The Path Glyph}]
		\nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
				{Purpose}/{Check if file \(D\) exists and is readable},%
				{Mechanism}/{Attempts \texttt{getline}; closes if successful},%
				{Return}/{1 if file is readable, 0 otherwise},%
				{Use Case}/{File validation, path probing, or conditional loading}
		}
\end{NxLightListBox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nxSections{Environment Variable Normalizer}{2}

\begin{NxCodeBox}{awk}{title={nx\_to\_environ(D)}}
function nx_to_environ(D,		m)
{
		D = toupper(nx_trim_str(D))
		gsub(/[ \t]/, "_", D)
		if (! (m = sub(/^[.]/, "L_", D)))
		if (! (m = sub(/^[*]/, "G_", D)))
		if (! (m = sub(/^[@]/, "NEXUS_", D)))
		if (! (m = sub(/^[%]/, "P_", D)))
				sub(/^[0-9]/, "_\\&", D)
		gsub(/[^0-9A-Z_]/, "", D)
		return D
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={Environment Variable Normalizer — The Uppercase Glyph}]
		\nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
				{Purpose}/{Normalize string \(D\) into a valid environment variable name},%
				{Trimming}/{Applies \texttt{nx\_trim\_str} and uppercases the result},%
				{Prefix Rules}/{\texttt{.} \nxArw{2} \texttt{L\_}, \texttt{*} \nxArw{2} \texttt{G\_}, \texttt{@} \nxArw{2} \texttt{NEXUS\_}, \texttt{\%} \nxArw{2} \texttt{P\_}},%
				{Digit Prefix}/{If \(D\) starts with digit, prepends underscore},%
				{Sanitization}/{Removes all non-alphanumeric and non-underscore glyphs},%
				{Use Case}/{Transforming symbolic identifiers into shell-safe environment keys}%
		}
\end{NxLightListBox}

\nxSections{Presence Evaluator}{2}

\begin{NxCodeBox}{awk}{title={\_\_nx\_defined(D, B)}}
function __nx_defined(D, B)
{
				return (D || (length(D) && B))
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={Presence Evaluator — The Defined Glyph}]
		\nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
				{Purpose}/{Determines whether value \(D\) is considered present or truthy},%
				{Input}/{\(D\): value to check; \(B\): fallback flag},%
				{Logic}/{Returns true if \(D\) is non-empty or if \(length(D)\) and \(B\) are both true},%
				{Use Case}/{Used by conditional glyphs to evaluate presence, fallback, or symbolic truth}%
		}
\end{NxLightListBox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nxSections{Fallback Selector}{2}

\begin{NxCodeBox}{awk}{title={\_\_nx\_else(D1, D2, B)}}
function __nx_else(D1, D2, B)
{
		if (D1 || __nx_defined(D1, B))
				return D1
		return D2
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={Fallback Selector — The Else Glyph}]
		\nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
				{Purpose}/{Returns \(D1\) if defined or truthy, otherwise returns fallback \(D2\)},%
				{Input}/{\(D1\): primary value; \(D2\): fallback value; \(B\): optional presence flag},%
				{Logic}/{Uses \texttt{\_\_nx\_defined(D1, B)} to determine presence},%
				{Use Case}/{Used in conditional chains, defaulting logic, or symbolic substitution}
		}
\end{NxLightListBox}

\nxSections{Conditional Selector}{2}

\begin{NxCodeBox}{awk}{title={\_\_nx\_if(B1, D1, D2, B2)}}
function __nx_if(B1, D1, D2, B2)
{
		if (B1 || __nx_defined(B1, B2))
				return D1
		return D2
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={Conditional Selector — The If Glyph}]
		\nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
				{Purpose}/{Returns \(D1\) if condition \(B1\) is true or defined, otherwise returns fallback \(D2\)},%
				{Input}/{\(B1\): primary condition; \(D1\): value if true; \(D2\): value if false; \(B2\): optional presence flag},%
				{Logic}/{Uses \texttt{\_\_nx\_defined(B1, B2)} to evaluate symbolic truth},%
				{Use Case}/{Conditional rendering, symbolic branching, or fallback substitution in AWK emitters}
		}
\end{NxLightListBox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nxSections{Ternary Divergence}{2}

\begin{NxCodeBox}{awk}{title={\_\_nx\_elif(B1, B2, B3, B4, B5, B6)}}
function __nx_elif(B1, B2, B3, B4, B5, B6)
{
    if (B4) {
        B5 = __nx_else(B5, B4)
        B6 = __nx_else(B6, B5)
    }
    return (__nx_defined(B1, B4) == __nx_defined(B2, B5) &&
            __nx_defined(B3, B6) != __nx_defined(B1, B4))
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={Ternary Divergence — The Elif Glyph}]
    \nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
        {Purpose}/{Evaluates a three-way conditional divergence based on symbolic presence and equality},%
        {Input}/{\(B1, B2, B3\): primary conditions; \(B4, B5, B6\): optional fallback values},%
        {Fallback}/{Each fallback is resolved via \texttt{\_\_nx\_else} to normalize symbolic presence},%
        {Logic}/{Returns true if \(\texttt{defined}(B1) = \texttt{defined}(B2)\) and \(\texttt{defined}(B3) \ne \texttt{defined}(B1)\)},%
        {Use Case}/{Used in chained conditional branches where symbolic presence and divergence must be tested}
    }
\end{NxLightListBox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nxSections{Conditional Union}{2}

\begin{NxCodeBox}{awk}{title={\_\_nx\_or(B1, B2, B3, B4, B5, B6)}}
function __nx_or(B1, B2, B3, B4, B5, B6)
{
    if (B4) {
        B5 = __nx_else(B5, B4)
        B6 = __nx_else(B6, B5)
    }
    return ((__nx_defined(B1, B4) && __nx_defined(B2, B5)) ||
            (__nx_defined(B3, B6) && ! __nx_defined(B1, B4)))
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={Conditional Union — The Or Glyph}]
    \nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
        {Purpose}/{Evaluates symbolic union of conditions with fallback normalization},%
        {Input}/{\(B1, B2, B3\): primary conditions; \(B4, B5, B6\): optional fallback values},%
        {Fallback}/{Each fallback is resolved via \texttt{\_\_nx\_else} to normalize symbolic presence},%
        {Logic}/{Returns true if \texttt{defined(B1) and defined(B2)} or \texttt{defined(B3) and not defined(B1)}},%
        {Use Case}/{Used in conditional branching, symbolic union, or fallback-aware logic overlays}
    }
\end{NxLightListBox}

\begin{NxCodeBox}{awk}{title={\textbf{Logical OR with both primary values defined}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Inputs}/{Left: \texttt{"yes"}, Right: \texttt{"ok"}},%
                {Operation}/{Both values are defined},%
                {Expected Result}/{Returns \texttt{true}}
            }
        \end{NxDarkList}
}}

__nx_or("yes", "ok", "", "", "", "")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Logical OR with only fallback defined}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Inputs}/{Fallback: \texttt{"fallback"}, Primaries: \texttt{""}},%
                {Operation}/{Evaluates fallback since primaries are undefined},%
                {Expected Result}/{Returns \texttt{true}}
            }
        \end{NxDarkList}
}}

__nx_or("", "", "fallback", "", "", "")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Logical OR with all values undefined}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Inputs}/{All arguments empty},%
                {Operation}/{No defined values to satisfy OR condition},%
                {Expected Result}/{Returns \texttt{false}}
            }
        \end{NxDarkList}
}}

__nx_or("", "", "", "", "", "")
\end{NxCodeBox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nxSections{Exclusive Divergence}{2}

\begin{NxCodeBox}{awk}{title={\_\_nx\_xor(B1, B2, B3, B4)}}
function __nx_xor(B1, B2, B3, B4)
{
    if (B3)
        B4 = __nx_else(B4, B3)
    return ((! __nx_defined(B2, B4) && __nx_defined(B1, B3)) ||
            (__nx_defined(B2, B4) && ! __nx_defined(B1, B3)))
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={Exclusive Divergence — The Xor Glyph}]
    \nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
        {Purpose}/{Returns true if exactly one of the two symbolic conditions is defined or truthy},%
        {Input}/{\(B1, B2\): primary conditions; \(B3, B4\): optional fallback values},%
        {Fallback}/{\(B4\) is resolved via \texttt{\_\_nx\_else(B4, B3)}},%
        {Logic}/{Returns true if one is defined and the other is not},%
        {Use Case}/{Used in symbolic branching, exclusive logic, or markup divergence testing}
    }
\end{NxLightListBox}

\begin{NxCodeBox}{awk}{title={\textbf{Exclusive-or with only the first value defined}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Inputs}/{Left: \texttt{"yes"}, Right: \texttt{""}},%
                {Operation}/{One side defined, the other undefined},%
                {Expected Result}/{Returns \texttt{true}}
            }
        \end{NxDarkList}
}}

__nx_xor("yes", "", "", "")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Exclusive-or with both values defined}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Inputs}/{Left: \texttt{"yes"}, Right: \texttt{"ok"}},%
                {Operation}/{Both sides defined},%
                {Expected Result}/{Returns \texttt{false}}
            }
        \end{NxDarkList}
}}

__nx_xor("yes", "ok", "", "")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Exclusive-or with only the fallback defined}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Inputs}/{Fallback: \texttt{"fallback"}, Others: \texttt{""}},%
                {Operation}/{One side defined via fallback, the other undefined},%
                {Expected Result}/{Returns \texttt{true}}
            }
        \end{NxDarkList}
}}

__nx_xor("", "", "fallback", "")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Exclusive-or with only the first value defined}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Inputs}/{Left: \texttt{"yes"}, Right: \texttt{""}},%
                {Operation}/{One side defined, the other undefined},%
                {Expected Result}/{Returns \texttt{true}}
            }
        \end{NxDarkList}
}}

__nx_xor("yes", "", "", "")
\end{NxCodeBox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nxSections{Symbolic Comparator}{2}

\begin{NxCodeBox}{awk}{title={\_\_nx\_compare(B1, B2, B3, B4)}}
function __nx_compare(B1, B2, B3, B4)
{
    if (! B3) {
        if (length(B3)) {
            B1 = length(B1)
            B2 = length(B2)
        } else if (nx_digit(B1, 1) && nx_digit(B2, 1)) {
            B1 = +B1
            B2 = +B2
        } else {
            B1 = "a" B1
            B2 = "a" B2
        }
        B3 = 1
    }
    if (B4)
        return __nx_if(nx_digit(B4), B1 > B2, B1 < B2) ||
               __nx_if(__nx_else(nx_digit(B4) == 1, tolower(B4) == "i"), B1 == B2, 0)
    if (length(B4))
        return B1 ~ B2
    return B1 == B2
}
\end{NxCodeBox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{NxLightListBox}[title={Symbolic Comparator — The Compare Glyph}]
    \nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
        {Purpose}/{Compares two values \(B1\) and \(B2\) using symbolic or numeric logic},%
        {Input}/{\(B1, B2\): values to compare; \(B3\): mode flag; \(B4\): comparison operator},%
        {Mode}/{If \(B3\) is empty, auto-selects: length, numeric, or string coercion},%
        {Operator}/{If \(B4\) is set: \texttt{digit} \nxArw{2} numeric compare, \texttt{i} \nxArw{2} equality, else regex match},%
        {Use Case}/{Used in symbolic evaluation, numeric comparison, or pattern matching logic}
    }
\end{NxLightListBox}

\begin{NxCodeBox}{awk}{title={\textbf{Compare two numeric strings using digit-based operator}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Inputs}/{Left: \texttt{"5"}, Right: \texttt{"10"}, Mode: \texttt{""}, Operator: \texttt{"1"}},%
                {Operation}/{Numeric comparison with coercion via digit detection},%
                {Expected Result}/{Returns \texttt{true} since \texttt{5 < 10}}
            }
        \end{NxDarkList}
}}

__nx_compare("5", "10", "", "1")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Match string against pattern using regex operator}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Inputs}/{Left: \texttt{"abc"}, Operator: \texttt{"~"}, Right: \texttt{"b"}},%
                {Mode}/{Regex match against pattern \texttt{"b"}},%
                {Expected Result}/{Returns \texttt{true} since \texttt{"abc"} contains \texttt{"b"}}
            }
        \end{NxDarkList}
}}

__nx_equality("abc", "~", "b")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Compare two strings using alphabetic equality operator}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Inputs}/{Left: \texttt{"abc"}, Operator: \texttt{"=a"}, Right: \texttt{"abc"}},%
                {Mode}/{Alphabetic equality check},%
                {Expected Result}/{Returns \texttt{true} since both strings are equal}
            }
        \end{NxDarkList}
}}

__nx_equality("abc", "=a", "abc")
\end{NxCodeBox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nxSections{Symbolic Equality Evaluator}{2}

\begin{NxCodeBox}{awk}{title={\_\_nx\_equality(B1, B2, B3)}}
function __nx_equality(B1, B2, B3,  b, e, g)
{
    b = substr(B2, 1, 1)
    if (b == ">") {
        e = 2
        g = 1
    } else if (b == "<") {
        e = "a"
        g = "i"
    } else if (b == "=") {
        e = ""
    } else if (b == "~") {
        e = 0
    } else {
        b = ""
    }
    if (b) {
        if (__nx_compare(substr(B2, 2, 1), "=", 1)) {
            b = g
        } else {
            b = e
        }
        e = substr(B2, length(B2), 1)
        if (__nx_compare(e, "a", 1))
            return __nx_compare(B1, B3, "", b)
        else if (__nx_compare(e, "_", 1))
            return __nx_compare(B1, B3, 0, b)
        else
            return __nx_compare(B1, B3, 1, b)
    }
    return __nx_compare(B1, B2)
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={Symbolic Equality Evaluator — The Equality Glyph}]
    \nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
        {Purpose}/{Evaluates symbolic equality or comparison between \(B1\) and \(B3\) using operator \(B2\)},%
        {Input}/{\(B1\): left value; \(B2\): operator string; \(B3\): right value},%
        {Operators}/{Supports \texttt{>}, \texttt{<}, \texttt{=}, \texttt{~} with optional suffixes (\texttt{a}, \texttt{\_}, etc.)},%
        {Logic}/{Delegates to \texttt{\_\_nx\_compare} with inferred mode and operator},%
        {Use Case}/{Used in symbolic evaluation, conditional logic, or markup comparison overlays}
    }
\end{NxLightListBox}

\begin{NxCodeBox}{awk}{title={\textbf{Compare two numeric strings using digit-based operator}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Inputs}/{Left: \texttt{"5"}, Operator: \texttt{">0"}, Right: \texttt{"3"}},%
                {Mode}/{Numeric comparison using digit coercion},%
                {Expected Result}/{Returns \texttt{true} since \texttt{5 > 3}}
            }
        \end{NxDarkList}
}}

__nx_equality("5", ">0", "3")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Match string against pattern using regex operator}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Inputs}/{Left: \texttt{"abc"}, Operator: \texttt{"\~"}, Right: \texttt{"b"}},%
                {Mode}/{Regex match against pattern \texttt{"b"}},%
                {Expected Result}/{Returns \texttt{true} since \texttt{"abc"} contains \texttt{"b"}}
            }
        \end{NxDarkList}
}}

__nx_equality("abc", "~", "b")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Compare two strings using alphabetic equality operator}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Inputs}/{Left: \texttt{"abc"}, Operator: \texttt{"=a"}, Right: \texttt{"abc"}},%
                {Mode}/{Alphabetic equality check},%
                {Expected Result}/{Returns \texttt{true} since both strings are equal}
            }
        \end{NxDarkList}
}}

__nx_equality("abc", "=a", "abc")
\end{NxCodeBox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nxSections{Associative Pair Swapper}{2}

\begin{NxCodeBox}{awk}{title={\_\_nx\_swap(V, D1, D2, t)}}
function __nx_swap(V, D1, D2,   t)
{
    t = V[D1]
    V[D1] = V[D2]
    V[D2] = t
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={Associative Pair Swapper — The Swap Glyph}]
    \nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
        {Purpose}/{Swaps the values of keys \(D1\) and \(D2\) in associative array \(V\)},%
        {Input}/{\(V\): associative array; \(D1, D2\): keys to swap},%
        {Mechanism}/{Temporarily stores \(V[D1]\), then performs the exchange},%
        {Use Case}/{Used in sorting, reordering, or symbolic mutation of key-value pairs}
    }
\end{NxLightListBox}

\begin{NxCodeBox}{awk}{title={\textbf{Swapping values between two keys in an associative array}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Initial State}/{\texttt{V["a"] = 1}, \texttt{V["b"] = 2}},%
                {Operation}/{Swap the values of keys \texttt{"a"} and \texttt{"b"}},%
                {Expected Result}/{\texttt{V["a"] = 2}, \texttt{V["b"] = 1}}
            }
        \end{NxDarkList}
}}

V["a"] = 1
V["b"] = 2
__nx_swap(V, "a", "b")
\end{NxCodeBox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nxSections{Filesystem Path Conductor}{2}
\begin{NxCodeBox}{awk}{title={nx\_file\_path(D1, B, D2)}}
function nx_file_path(D1, B, D2,    i, j)
{
    D2 = __nx_else(D2, "/")
    if (! sub(/^-/, ENVIRON["OLDPWD"], D1))
    if (! sub(/^~/, ENVIRON["HOME"], D1))
    if (! sub(/^NX_L:/, ENVIRON["NEXUS_LIB"], D1))
    if (! sub(/^NX_C:/, ENVIRON["NEXUS_CNF"], D1))
    if (! sub(/^NX_D:/, ENVIRON["NEXUS_DOCS"], D1))
    if (! sub(/^NX_E:/, ENVIRON["NEXUS_ENV"], D1))
    if (! sub(/^NX_SB:/, ENVIRON["NEXUS_SBIN"], D1))
    if (! sub(/^NX_B:/, ENVIRON["NEXUS_BIN"], D1))
    if (! sub(/^NX_J:/, ENVIRON["NEXUS_LIB"] "java" D2 ENVIRON["G_NEX_JAVA_PROJECT"], D1))
        sub(/^NX_S:/, ENVIRON["NEXUS_SRC"], D1)
    gsub(D2 "+", D2, D1)
    gsub(D2 "+$", "", D1)
    i = D1
    if (! sub("[^" D2 "]+$", "", i))
        return D1
    i = length(i)
    j = length(D2)
    if (B == "")
        return substr(D1, i + j)
    if (B == 0)
        return D1
    return substr(D1, 1, i - j)
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={Filesystem Path Conductor — The Path Glyph}]
    \nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
        {Purpose}/{Resolves symbolic prefixes and returns basename, dirname, or full path},%
        {Input}/{\(D1\): path string; \(B\): toggle; \(D2\): separator (default "/")},%
        {Prefixes}/{Symbols like \texttt{NX\_C:}, \texttt{NX\_L:}, etc. expand to environment variables. 
        \textbf{Note:} The actual expansion depends on your runtime environment. For example, \texttt{NX\_C:} may expand to \texttt{/opt/posix-nexus/cnf} on one system, but to a different directory elsewhere.},%
        {Mechanism}/{Expands environment variables, normalizes separators, slices basename/dirname},%
        {Use Case}/{Used in config resolution, daemon overlays, or IPC path normalization}
    }
\end{NxLightListBox}

\begin{NxCodeBox}{awk}{title={\textbf{Return full expanded path when toggle is 0}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Input}/{\texttt{"NX\_C:/file7.txt"}, Toggle: \texttt{0}},%
                {Expansion}/{Prefix \texttt{NX\_C:} \nxArw{2} environment variable \texttt{NEXUS\_CNF}},%
                {Expected Result}/{\texttt{\$NEXUS\_CNF/file7.txt}}
            }
        \end{NxDarkList}
}}
print nx_file_path("NX_C:/file7.txt", 0)
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Return basename when toggle is empty}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Input}/{\texttt{"NX\_C:/file7.txt"}},%
                {Expansion}/{Prefix \texttt{NX\_C:} \nxArw{2} environment variable \texttt{NEXUS\_CNF}},%
                {Expected Result}/{\texttt{file7.txt}}
            }
        \end{NxDarkList}
}}
print nx_file_path("NX_C:/file7.txt")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Return dirname when toggle is non-empty}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Input}/{\texttt{"NX\_C:/file7.txt"}, Toggle: \texttt{1}},%
                {Expansion}/{Prefix \texttt{NX\_C:} \nxArw{2} environment variable \texttt{NEXUS\_CNF}},%
                {Expected Result}/{\texttt{\$NEXUS\_CNF}}
            }
        \end{NxDarkList}
}}
print nx_file_path("NX_C:/file7.txt", 1)
\end{NxCodeBox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\nxSections{Unique File Resolver}{2}
\begin{NxCodeBox}{awk}{title={nx\_uniq\_file(D1, D2, V, D3)}}
function nx_uniq_file(D1, D2, V, D3,    b, r, d, i)
{
    b = nx_file_path(D1)
    D3 = __nx_else(D3, "/")
    r = D2 D3 D1
    if (nx_is_file(D1)) {
        r = D1
        d = nx_file_path(D1, 1)
    } else if (nx_is_file(r)) {
        d = nx_file_path(r, 1)
    } else {
        for (i = -1; i >= V[-0]; --i) {
            r = V[i] D2 b
            if (nx_is_file(r)) {
                d = nx_file_path(r, 1)
                break
            }
        }
    }
    if (d != "") {
        if (! (d in V))
            V[--V[-0]] = d
        if (! (r in V))
            V[++V[0]] = r
    }
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={Unique File Resolver — The Uniqueness Glyph}]
    \nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
        {Purpose}/{Ensures that only unique absolute file paths and their directories are tracked in hashmap \(V\)},%
        {Input}/{\(D1\): relative/absolute file path; \(D2\): base directory; \(V\): hashmap; \(D3\): separator},%
        {Mechanism}/{Checks if file exists directly, via base directory, or by searching known directories in \(V\)},%
        {Indexes}/{\([-0]\): list of unique directories; \([0]\): list of unique file realpaths},%
        {Use Case}/{Used in config loaders, IPC daemons, or overlay systems to avoid duplicate path entries}
    }
\end{NxLightListBox}

\begin{NxCodeBox}{awk}{title={\textbf{Resolve absolute path from relative input}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Input}/{\texttt{D1 = "file7.txt"}, \texttt{D2 = "/opt/posix-nexus/cnf"}},%
                {Check}/{Concatenate base directory with file \nxArw{2} \texttt{/opt/posix-nexus/cnf/file7.txt}},%
                {Expected Result}/{Adds directory \texttt{/opt/posix-nexus/cnf} to \texttt{V[-0]} and file path to \texttt{V[0]}}
            }
        \end{NxDarkList}
}}
nx_uniq_file("file7.txt", "/opt/posix-nexus/cnf", V)
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Handle already absolute path}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Input}/{\texttt{D1 = "/etc/nexus/restic.json"}},%
                {Check}/{File exists directly, no need to prepend base directory},%
                {Expected Result}/{Adds directory \texttt{/etc/nexus} to \texttt{V[-0]} and file path to \texttt{V[0]}}
            }
        \end{NxDarkList}
}}
nx_uniq_file("/etc/nexus/restic.json", "/opt/posix-nexus/cnf", V)
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Search known directories when file not found directly}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Input}/{\texttt{D1 = "config.json"}, \texttt{D2 = "/opt/posix-nexus/cnf"}},%
                {Check}/{Iterates over \texttt{V[-0]} directories to locate file},%
                {Expected Result}/{Once found, adds directory and file path uniquely to \texttt{V}}
            }
        \end{NxDarkList}
}}
nx_uniq_file("config.json", "/opt/posix-nexus/cnf", V)
\end{NxCodeBox}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nxSections{Escaped Sequence Matcher}{2}
\begin{NxCodeBox}{awk}{title={nx\_nesc\_match(D1, D2, D3)}}
function nx_nesc_match(D1, D2, D3,	f, l)
{
	if (D1 == "")
		return -1
	f = 0
	D2 = __nx_else(D2, " ")
	if ((D3 = __nx_else(D3, "\\\\", 1)) == "\\\\")
		l = 1
	else
		l = length(D3)
	while (match(D1, D2)) {
		f = f + RSTART
		if (! (match(substr(D1, 1, RSTART - 1), D3 "+$") && D3) || int(RLENGTH % 2) == 0)
			break
		f = f + RLENGTH - l
		D1 = substr(D1, f + 1)
	}
	return f
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={Escaped Sequence Matcher — The Escape Glyph}]
    \nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
        {Purpose}/{Finds the position of a delimiter in string \(D1\), respecting escape sequences},%
        {Input}/{\(D1\): target string; \(D2\): delimiter regex (default space); \(D3\): escape character regex (default backslash)},%
        {Mechanism}/{Iteratively searches for delimiter, checks if it is escaped by \(D3\), and advances accordingly},%
        {Return}/{Index of first unescaped delimiter, or \(-1\) if \(D1\) is empty},%
        {Use Case}/{Used in tokenization, argument parsing, or IPC relay parsing where escapes must be honored}
    }
\end{NxLightListBox}

\begin{NxCodeBox}{awk}{title={\textbf{Find first unescaped space in a string}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Input}/{\texttt{"foo bar"}},%
                {Delimiter}/{Space},%
                {Escape}/{Backslash},%
                {Expected Result}/{Returns \texttt{4}, the position of the space}
            }
        \end{NxDarkList}
}}
print nx_nesc_match("foo bar")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Skip escaped space}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Input}/{\texttt{"foo\\ bar baz"}},%
                {Delimiter}/{Space},%
                {Escape}/{Backslash},%
                {Expected Result}/{Returns \texttt{9}, the position of the unescaped space after \texttt{"bar"}}
            }
        \end{NxDarkList}
}}
print nx_nesc_match("foo\\ bar baz")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Handle double escape (escaped backslash before space)}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Input}/{\texttt{"foo\\\\ bar"}},%
                {Delimiter}/{Space},%
                {Escape}/{Backslash},%
                {Expected Result}/{Returns \texttt{5}, since the space is not escaped (two backslashes cancel)}
            }
        \end{NxDarkList}
}}
print nx_nesc_match("foo\\\\ bar")
\end{NxCodeBox}

\nxSections{Next Match Finder}{2}
\begin{NxCodeBox}{awk}{title={nx\_find\_next(D1, V, B, D2)}}
function nx_find_next(D1, V, B, D2,	i, f, m)
{
	if (D1 == "")
		return -1
	B = __nx_if(B, ">0", "<0")
	for (i in V) {
		m = nx_nesc_match(D1, V[i], D2)
		if (! f || __nx_equality(m, B, f))
			f = m
	}
	if (f != length(D1) && B == ">0")
		return f + 1
	return f
}i
\end{NxCodeBox}

\begin{NxLightListBox}[title={Next Match Finder — The Match Glyph}]
    \nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
        {Purpose}/{Finds the next delimiter match in string \(D1\) across a set of candidate patterns \(V\)},%
        {Input}/{\(D1\): target string; \(V\): array of delimiter regexes; \(B\): comparison toggle; \(D2\): escape character regex},%
        {Mechanism}/{Iterates over all patterns in \(V\), uses \texttt{nx\_nesc\_match} to locate matches, compares positions with \texttt{\_\_nx\_equality}},%
        {Comparison}/{If \(B\) is empty, defaults to \texttt{">0"} (find next greater); otherwise \texttt{"<0"}},%
        {Return}/{Index of the next matching delimiter, or \(-1\) if \(D1\) is empty},%
        {Use Case}/{Used in tokenization, parsing overlays, or IPC relays where multiple delimiters may apply}
    }
\end{NxLightListBox}

\begin{NxCodeBox}{awk}{title={\textbf{Find next space or comma in a string}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Input}/{\texttt{"foo, bar baz"}},%
                {Delimiters}/{\texttt{V[1] = ","}, \texttt{V[2] = " "}},%
                {Escape}/{Default backslash},%
                {Expected Result}/{Returns \texttt{4}, the position of the comma}
            }
        \end{NxDarkList}
}}
V[1] = ","
V[2] = " "
print nx_find_next("foo, bar baz", V)
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Skip escaped delimiter}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Input}/{\texttt{"foo\\,bar baz"}},%
                {Delimiters}/{\texttt{V[1] = ","}, \texttt{V[2] = " "}},%
                {Escape}/{Backslash},%
                {Expected Result}/{Returns \texttt{8}, the position of the space after \texttt{"bar"}}
            }
        \end{NxDarkList}
}}
V[1] = ","
V[2] = " "
print nx_find_next("foo\\,bar baz", V)
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Handle multiple delimiters with comparison toggle}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Input}/{\texttt{"alpha|beta gamma"}},%
                {Delimiters}/{\texttt{V[1] = "|"}, \texttt{V[2] = " "}},%
                {Toggle}/{Default \texttt{">0"} ensures smallest index chosen},%
                {Expected Result}/{Returns \texttt{6}, the position of the space after \texttt{"beta"}}
            }
        \end{NxDarkList}
}}
V[1] = "|"
V[2] = " "
print nx_find_next("alpha|beta gamma", V)
\end{NxCodeBox}

\nxSections{File Merge Conductor}{2}
\begin{NxCodeBox}{awk}{title={nx\_file\_merge(D1, D2, D3, D4)}}
function nx_file_merge(D1, D2, D3, D4,  stk, fls, trk)
{
    if (nx_uniq_file(D1, "", fls) != 1)
        return -1

    D4 = __nx_else(D4, "include", 1)

    # directive name
    trk["dir"] = "nx_" D4

    # directive sigil
    trk["sig"] = __nx_else(D2, "#", 1)

    # omit files if listed after directive
    if (D2 = nx_trim_split(D3, stk, "<nx:null/>")) {
        do {
            nx_uniq_file(que[D2], fls[fls["-0"]], fls)
        } while (--D2 > 0)
        split("", trk, "")
    }

    stk["rt"] = "."

    do {
        while ((getline D2 < D1) > 0) {
            if (D2 ~ "([ \t]+|^)" trk["sig"] trk["dir"] && match(D2, trk["sig"] trk["dir"] "[ \t]+")) {
                trk["cr"] = substr(D2, 1, RSTART - 1)
                D2 = substr(D2, RSTART + RLENGTH)

                if (match(D2, /^[^ \t]+/)) {
                    if (nx_uniq_file(substr(D2, RSTART, RLENGTH), fls[fls["-0"]], fls) != -1) {
                        __nx_file_merge_push(stk, trk["cr"])
                        trk[++trk[0]] = fls[fls[0]]
                        trk[fls[fls[0]]] = stk["rt"] "" ++stk[stk["rt"] "0"] "."
                        if ((trk["cr"] = substr(D2, RSTART + RLENGTH)) !~ /^[ \t]*$/)
                            trk["cr"] = trk["cr"] "\n"
                        __nx_file_merge_push(stk, trk["cr"])
                    } else {
                        __nx_file_merge_push(stk, trk["cr"] substr(D2, RSTART + RLENGTH) "\n")
                    }
                } else if (trk["cr"] !~ /^[ \t]*$/) {
                    __nx_file_merge_push(stk, trk["cr"] "\n")
                }
            } else if (D2 !~ /^[ \t]*$/) {
                __nx_file_merge_push(stk, D2 "\n")
            }
        }
        close(D1)

        D1 = trk[trk[0]]
        stk["rt"] = trk[trk[trk[0]]]
    } while (trk[0]-- > 0)

    delete trk
    delete fls
    nx_dfs(stk)
    for (D2 = 1; D2 <= stk[0]; D2++)
        printf(stk[stk[D2]])
    delete stk
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={File Merge Conductor — The Merge Glyph}]
    \nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
        {Purpose}/{Processes include directives in a file, merging referenced files into a unified output},%
        {Input}/{\(D1\): root file; \(D2\): directive sigil (default \#); \(D3\): omit list; \(D4\): directive keyword (default "include")},%
        {Mechanism}/{Scans lines, detects directives, resolves file paths via \texttt{nx\_uniq\_file}, pushes content into stack, recursively merges},%
        {Helpers}/{Uses \texttt{\_\_nx\_file\_merge\_push} and \texttt{\_\_nx\_file\_merge\_rt} to manage stack indices},%
        {Return}/{Prints merged file content to stdout},%
        {Use Case}/{Used in config overlays or script loaders where nested includes must be resolved safely}
    }
\end{NxLightListBox}

\begin{NxCodeBox}{awk}{title={\textbf{Merge file with include directive}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Root}/{\texttt{main.conf} contains line \texttt{\#nx\_include extra.conf}},%
                {Operation}/{Directive detected, \texttt{extra.conf} merged inline},%
                {Expected Result}/{Unified output with contents of both files}
            }
        \end{NxDarkList}
}}
nx_file_merge("main.conf")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Handle directive with non-existent file}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Root}/{\texttt{main.conf} contains \texttt{\#nx\_include missing.conf}},%
                {Operation}/{Directive match but file not found},%
                {Expected Result}/{Line preserved without directive expansion}
            }
        \end{NxDarkList}
}}
nx_file_merge("main.conf")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Omit files listed in exclusion list}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Root}/{\texttt{main.conf} with omit list \texttt{"extra.conf"}},%
                {Operation}/{Directive found but file excluded},%
                {Expected Result}/{File skipped, only root content printed}
            }
        \end{NxDarkList}
}}
nx_file_merge("main.conf", "#", "extra.conf")
\end{NxCodeBox}

