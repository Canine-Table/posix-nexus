\nxSections{Shell Modules}{1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nxSections{Environment Key Conductor}{2}
\begin{NxCodeBox}{awk}{title={nx\_to\_environ(D)}}
function nx_to_environ(D, m)
{
    D = toupper(nx_trim_str(D))
    gsub(/[ \t]/, "_", D)
    if (! (m = sub(/^[.]/, "L_", D)))
    if (! (m = sub(/^[*]/, "G_", D)))
    if (! (m = sub(/^[@]/, "NEXUS_", D)))
    if (! (m = sub(/^[%]/, "P_", D)))
        sub(/^[0-9]/, "_\\&", D)
    gsub(/[^0-9A-Z_]/, "", D)
    return D
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={Environment Key Glyph — nx\_to\_environ}]
    \nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
        {Purpose}/{Transforms a raw string into a valid environment variable key},%
        {Input}/{\texttt{D}: raw identifier string},%
        {Mechanism}/{Trims and uppercases string, replaces whitespace with underscores, applies prefix rules, sanitizes non-alphanumeric characters},%
        {Prefix Rules}/{\texttt{. → L\_}, \texttt{* → G\_}, \texttt{@ → NEXUS\_}, \texttt{\% → P\_}, leading digit → prefixed with underscore},%
        {Return}/{Normalized environment key string},%
        {Use Case}/{Used to convert arbitrary identifiers into safe environment variable names for overlays or system exports}
    }
\end{NxLightListBox}

\begin{NxCodeBox}{awk}{title={\textbf{Convert dotted identifier}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Input}/{\texttt{".config"}},%
                {Operation}/{\texttt{nx\_to\_environ(".config")}},%
                {Expected Result}/{Returns \texttt{"L\_CONFIG"}}
            }
        \end{NxDarkList}
}}
nx_to_environ(".config")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Convert starred identifier}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Input}/{\texttt{"*global"}},%
                {Operation}/{\texttt{nx\_to\_environ("*global")}},%
                {Expected Result}/{Returns \texttt{"G\_GLOBAL"}}
            }
        \end{NxDarkList}
}}
nx_to_environ("*global")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Convert at-prefixed identifier}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Input}/{\texttt{"@path"}},%
                {Operation}/{\texttt{nx\_to\_environ("@path")}},%
                {Expected Result}/{Returns \texttt{"NEXUS\_PATH"}}
            }
        \end{NxDarkList}
}}
nx_to_environ("@path")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Convert percent-prefixed identifier}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Input}/{\texttt{"\%param"}},%
                {Operation}/{\texttt{nx\_to\_environ("\%param")}},%
                {Expected Result}/{Returns \texttt{"P\_PARAM"}}%
            }
        \end{NxDarkList}
}}
nx_to_environ("%param")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Convert numeric-leading identifier}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Input}/{\texttt{"123abc"}},%
                {Operation}/{\texttt{nx\_to\_environ("123abc")}},%
                {Expected Result}/{Returns \texttt{"\_123ABC"}}
            }
        \end{NxDarkList}
}}
nx_to_environ("123abc")
\end{NxCodeBox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nxSections{Stringify Options Conductor}{2}
\begin{NxCodeBox}{awk}{title={\_\_nx\_stringify\_opts(V, D1, D2, D3, D4, D5, N)}}
function __nx_stringify_opts(V, D1, D2, D3, D4, D5, N, i, j)
{
    for (i in V) {
        gsub("'", "\\'", V[i])
        D1 = nx_join_str(D1,
            "NEX_" D2 "" ++j "=\x27" i "\x27 NEX_" D2 "_" i "=\x27" V[i] "\x27",
            D4)
        if (N > 2)
            nx_ansi_info("(" D3 ") " i " = " V[i] "\n")
    }
    return nx_join_str(D1, "NEX_" D2 "=\x27" trk["i"] "\x27" D5, D4)
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={Stringify Options Glyph — \_\_nx\_stringify\_opts}]
    \nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
        {Purpose}/{Converts associative array \texttt{V} into environment-style option strings},%
        {Input}/{\texttt{V}: option map; \texttt{D1}: accumulator string; \texttt{D2}: option prefix; \texttt{D3}: label; \texttt{D4}: delimiter; \texttt{D5}: suffix; \texttt{N}: verbosity toggle},%
        {Mechanism}/{Iterates over \texttt{V}, escapes quotes, appends formatted \texttt{NEX\_*} assignments into \texttt{D1}, optionally prints ANSI info},%
        {Output}/{Returns concatenated string of environment-style assignments},%
        {Use Case}/{Used to serialize options into exportable environment variables for overlay systems}
    }
\end{NxLightListBox}

\begin{NxCodeBox}{awk}{title={\textbf{Serialize options with prefix "CFG"}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {State}/{\texttt{V["path"]="usr/bin"}, \texttt{V["mode"]="debug"}},%
                {Operation}/{\texttt{\_\_nx\_stringify\_opts(V, "", "CFG", "opts", ";", "", 3)}},%
                {Expected Result}/{Returns string with assignments like \texttt{NEX\_CFG1='path' NEX\_CFG\_path='usr/bin'; NEX\_CFG2='mode' NEX\_CFG\_mode='debug'} and prints ANSI info}
            }
        \end{NxDarkList}
}}
__nx_stringify_opts(V, "", "CFG", "opts", ";", "", 3)
\end{NxCodeBox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\nxSections{Shell Option Arguments Conductor}{2}
\begin{NxCodeBox}{awk}{title={nx\_sh\_optargs(D1, N, D2, D3, D4)}}
function nx_sh_optargs(D1, N, D2, D3, D4,
    args, trk, stk, kwdas, kwds, grp, grps, flgs, grpa, grpas)
{
  # Check if the input string D1 is not empty
	if (D1 == "")
		return -1

	trk["ps"] = __nx_else(D2, "<nx:null/>") # Param sep
	trk["ag"] = split(D1, args, trk["ps"])
	if (N > 2)
		print args[1]

	# Define default delimiters
	trk["ds"] = __nx_else(D3, ",")
	split(D4, stk, trk["ds"])
	trk["ks"] = __nx_else(stk[1], ":") # key sep
	trk["fs"] = __nx_else(stk[2], "=") # optional flag sep
	trk["as"] = __nx_else(stk[3], "@") # appendable kwds sep

	trk["ka"] = __nx_else(stk[4], "%") # future use

	# groups
	trk["go"] = __nx_else(stk[5], "<") # begin group
	trk["gc"] = __nx_else(stk[6], ">") # eng group
	nx_bijective(trk, trk["gc"], trk["go"]) # bijective  results
	trk["gs"] = trk["go"] # initial state

	trk["lo"] = __nx_else(stk[7], "~") # begin long option
	trk["lc"] = __nx_else(stk[8], "-") # end long option
	nx_bijective(trk, trk["lc"], trk["lo"]) # bijective  results
	trk["ls"] = trk["lo"] # initial state

	trk["ln"] = split(args[1], stk, "")

	for (trk["i"] = 1;  trk["i"] <= trk["ln"]; ++trk["i"]) {
		if (nx_is_alpha(stk[trk["i"]]) && (stk[trk["i"] + 1] != trk["as"] && stk[trk["i"] + 1] != trk["go"] && stk[trk["i"] + 1] != trk["ks"])) {
			if (trk["gl"]) {
				if (trk["glj"] == 1) {
					grp[stk[trk["i"]]] = trk["gl"]
					if (N > 3)
						nx_ansi_debug("(group member added) " trk["gl"] ": " stk[trk["i"]] "\n")
				} else if (trk["glj"] == 2) {
					grpa[stk[trk["i"]]] = trk["gl"]
					if (N > 3)
						nx_ansi_debug("(group array member added) " trk["gl"] ": " stk[trk["i"]] "\n")
				} else {
					if (N > 0)
						nx_ansi_error("an overflow or a you forgot somethiing here in nex-sh!" "\n")
					D1 = -1
					break
				}
			} else {
				flgs[stk[trk["i"]]] = ""
				if (N > 3)
					print "(flag detected) " stk[trk["i"]]
			}
		} else if (stk[trk["i"]] == trk["gs"]) { # group?
			if (stk[trk["i"]] == trk["go"] && ! trk["glj"]) { # is it the begining of a group??
				trk["gl"] = stk[trk["i"] - 1] # group leader
				if (stk[trk["i"] + 1] == trk["as"]) {
					trk["i"]++
					if (N > 3)
						nx_ansi_debug("(group array toggle on) " trk["gl"] "\n")
					grpas[trk["gl"]] = ""
					trk["glj"] = 2
				} else {
					grps[trk["gl"]] = ""
					if (N > 3)
						nx_ansi_debug("(group toggle on) " trk["gl"] "\n")
					trk["glj"] = 1
				}
			} else if (trk["glj"] && stk[trk["i"]] == trk["gc"]) {
				if (N > 3) {
					if (trk["glj"] == 1)
						nx_ansi_debug("(group toggle off) " trk["gl"] "\n")
					else if (trk["glj"] == 2)
						nx_ansi_debug("(group array toggle off) " trk["gl"] "\n")
				}
				trk["gl"] = "" # unset the group leader
				trk["glj"] = 0
			} else {
				if (N > 0)
					nx_ansi_error("im not sure whats going on over here!\n")
				D1 = -1
				break
			}
			trk["gs"] = trk[trk["gs"]]
		} else if (nx_is_alpha(stk[trk["i"]])) {
			if (stk[trk["i"] + 1] == trk["ks"]) {
				if (N > 3)
					nx_ansi_debug("(key word detected) " stk[trk["i"]] "\n")
				kwds[stk[trk["i"]++]] = ""
			} else if (stk[trk["i"] + 1] == trk["as"]) {
				if (N > 3)
					nx_ansi_debug("(key word array detected) " stk[trk["i"]] "\n")
				kwdas[stk[trk["i"]++]] = ""
			}
		}
		D1 = 0
	}

	if (D1 != -1) {
		D1 = ""
		for (trk["i"] = 2; trk["i"] <= trk["ag"]; ++trk["i"]) {
			if (args[trk["i"]] == "--")
				break
			trk["ln"] = split(args[trk["i"]], stk, "")
			if (stk[1] == "-") {
				if (N > 3)
					nx_ansi_debug("(param) " args[trk["i"]] "\n")
				if (stk[2] in grpa) {
					grpas[grpa[stk[2]]] = nx_join_str(grpas[grpa[stk[2]]] , stk[2], trk["ps"])
					if (N > 3)
						nx_ansi_debug("(group array member of '" grpa[stk[2]] "') " stk[2] "\n")
				} else if (stk[2] in grp) {
					grps[grp[stk[2]]] = stk[2]
					if (N > 3)
						nx_ansi_debug("(group member of '" grp[stk[2]] "') " stk[2] "\n")
				} else if (stk[2] in flgs) {
					if (N > 3)
						nx_ansi_debug("(flag) %s: " stk[2])
					if (stk[3] == trk["fs"]) {
						flgs[stk[2]] = substr(args[trk["i"]], 4)
					} else if (trk["ln"] > 2) {
						flgs[stk[2]] = substr(args[trk["i"]], 3)
					} else {
						nx_boolean(flgs, stk[2])
					}
					if (N > 3)
						nx_ansi_print("D%\0\n" flgs[stk[2]])
				} else if (stk[2] in kwds) {
					kwds[stk[2]] = args[++trk["i"]]
					if (N > 3)
						nx_ansi_debug("(key words) " stk[2] ": " args[trk["i"]] "\n")
				} else if (stk[2] in kwdas) {
					kwdas[stk[2]] = nx_join_str(kwdas[stk[2]], args[++trk["i"]], trk["ps"])
					if (N > 3)
						nx_ansi_debug("(key word array) " stk[2] ": " kwdas[stk[2]] "\n")
				} else {
					D1 = nx_join_str(D1, args[trk["i"]], trk["ps"])
					if (N > 1)
						nx_ansi_warning("(unknown arg) " args[trk["i"]] "\n")
				}
			} else {
				D1 = nx_join_str(D1, args[trk["i"]], trk["ps"])
				if (N > 3)
					nx_ansi_debug("(remainder) " args[trk["i"]] "\n")
			}
		}

		delete grp
		if (N > 2)
			nx_ansi_info("(rmdr) " D1)
		gsub("'", "\\'", D1)
		D3 = D1
		gsub(trk["ps"], " ", D3)
		D1 = "NEX_R=\x27" D1 "\x27 \\\n NEX_S=\x27" D3 "\x27 \\\n"
		D1 = __nx_stringify_opts(kwds, D1, "k", "kwds", " ", " \\\n", N)
		D1 = __nx_stringify_opts(kwdas, D1, "K", "kwdas", " ", " \\\n", N)
		D1 = __nx_stringify_opts(grps, D1, "g", "grps", " ", " \\\n", N)
		D1 = __nx_stringify_opts(grpas, D1, "G", "grpas", " ", " \\\n", N)
		D1 = __nx_stringify_opts(flgs, D1, "f", "flgs", " ", "; # Nex is done here\n", N)
	}
	delete trk
	delete stk
	delete args
	return D1
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={Shell Option Arguments Glyph — nx\_sh\_optargs}]
    \nxEachLabel{ArrowDark}{Secondary}{{1}{43}}{%
        {Purpose}/{Parses a shell-style argument string into flags, keywords, groups, and arrays},%
        {Input}/{\texttt{D1}: raw argument string; \texttt{N}: verbosity/debug level; \texttt{D2}: param separator; \texttt{D3}: delimiter set; \texttt{D4}: custom delimiters},%
        {Mechanism}/{Splits input into tokens, defines separators (key, flag, appendable, group, long option), detects flags, keywords, groups, arrays, and remainder args},%
        {Groups}/{Supports group toggles (\texttt{<...>}) and group arrays (\texttt{<...@>}), tracked via bijective mapping},%
        {Flags}/{Single-letter flags parsed, optional values via \texttt{=} or concatenation},%
        {Keywords}/{Key-value pairs (\texttt{k: v}) and keyword arrays (\texttt{k@ v1 v2})},%
        {Output}/{Returns environment-style string with \texttt{NEX\_*} assignments for remainder, flags, keywords, groups},%
        {Use Case}/{Used to normalize shell option parsing into structured environment variables for Nex overlay systems}
    }
\end{NxLightListBox}

\begin{NxCodeBox}{awk}{title={\textbf{Parse simple flags}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Input}/{\texttt{"-a -b"}},%
                {Operation}/{\texttt{nx\_sh\_optargs("-a -b", 3)}},%
                {Expected Result}/{Flags \texttt{a}, \texttt{b} detected, returned as \texttt{NEX\_f\_a}, \texttt{NEX\_f\_b}}
            }
        \end{NxDarkList}
}}
nx_sh_optargs("-a -b", 3)
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Parse keyword arguments}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Input}/{\texttt{"-x key:value"}},%
                {Operation}/{\texttt{nx\_sh\_optargs("-x key:value", 3)}},%
                {Expected Result}/{Keyword \texttt{key} stored with value \texttt{value}, returned as \texttt{NEX\_k\_key}}
            }
        \end{NxDarkList}
}}
nx_sh_optargs("-x key:value", 3)
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Parse grouped flags}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Input}/{\texttt{"-g a<b c>"}},%
                {Operation}/{\texttt{nx\_sh\_optargs("-g a<b c>", 3)}},%
                {Expected Result}/{Group \texttt{a} with members \texttt{c}, returned as \texttt{NEX\_g\_a}}
            }
        \end{NxDarkList}
}}
nx_sh_optargs("-g a<b c>", 3)
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Parse keyword arrays}
        \begin{NxDarkList}
            \nxEachLabel{CodePrimary}{Tertiary}{{1}{43}}{%
                {Input}/{\texttt{"-k opt@ val1 val2"}},%
                {Operation}/{\texttt{nx\_sh\_optargs("-k opt@ val1 val2", 3)}},%
                {Expected Result}/{Keyword array \texttt{opt} with values \texttt{val1,val2}, returned as \texttt{NEX\_K\_opt}}
            }
        \end{NxDarkList}
}}
nx_sh_optargs("-k opt@ val1 val2", 3)
\end{NxCodeBox}

\begin{NxLightBox}[title={Shell Option Separators — Syntax Glyph Map}]
    \begin{tabularx}{\textwidth}{|l|X|X|}
        \hline
        \textbf{Separator} & \textbf{Role} & \textbf{Example} \\
        \hline
        \nxLnArcBox[]{:} & Key separator & key:value → NEX\_k\_key='value' \\
        \hline
        \nxLnArcBox[]{=} & Flag separator &-f=value → NEX\_f\_f='value' \\
        \hline
        \nxLnArcBox[]{@} & Keyword array separator & opt@ v1 v2 → NEX\_K\_opt='v1,v2' \\
        \hline
        \nxLnArcBox[]{< >} & Group delimiters & a<b c> → group 'a' with member 'c' \\
        \hline
    \end{tabularx}
\end{NxLightBox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

