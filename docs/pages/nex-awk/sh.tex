\nxSections{Shell Modules}{1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nxSections{The Argument Registry}{2}

\begin{empheq}[box=\nxWarningMathBox]{align*}
	A_g &= \text{leader aliases} + \text{member aliases} \\
	S_g &= 1 + A_g
		&& \text{(canonical leader slot + alias slots)} \\
	S_{\text{groups}} &= \sum_g S_g
		= \sum_g (1 + A_g) \\
	S_{\text{base}} &= 12
		&& \text{(fixed non-group stride slots)} \\
	S_{\text{total}} &= S_{\text{base}} + S_{\text{groups}}
\end{empheq}
\bigskip

\nxSections{The Argument Tokenizer}{2}
\begin{NxCodeBox}{awk}{phantomlabel={func:nx_sh_opts}, title={\textbf{Shell Option Tokenizer Arguments}
	\begin{NxDarkList}
		\nxEachArw{CodePrimary}{Tertiary}{1}{%
			{D1}/{Option string to tokenize (raw input)},%
			{N}/{Debug level: \begin{NxDarkList}
				\nxEachArw{BugSuccess}{Tertiary}{1}{%
						{0}/{silent},%
						{>0}/{errors only},%
						{>1}/{warnings},%
						{>2}/{verbose audit},%
						{>3}/{mapping summary},%
						{>4}/{full dump}%
					}
				\end{NxDarkList}},%
				{V}/{Array to populate with parsed flags, keywords, arrays, groups},%
				{D2}/{Separator of separators (defaults to comma)},%
				{D3}/{List of separator characters (key, alias, array, group, etc.)}%
			}
	\end{NxDarkList}
}}
function nx_sh_opts(D1, N, V, D2, D3)
\end{NxCodeBox}

\begin{NxLightListBox}[title={Usage essentials}]
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{Flags}/{Standalone options, stride slot 4},%
		{Keywords}/{Key/value pairs, stride slot 1},%
		{Flag arrays}/{Appendable flags, stride slot 7},%
		{Keyword arrays}/{Appendable keywords, stride slot 10},%
		{Groups}/{Leaders + members, stride slot 13+},%
		{Aliases}/{Use '\&' immediately after option},%
		{Separators}/{Use non-alphanumeric single characters},%
		{Logging}/{Set N for verbosity level}%
	}
\end{NxLightListBox}

\nxSections{Option Separators D3}{3}

\begin{NxLightBox}[title={Variable Positions in trk}, phantomlabel={func:nx_sh_opts:D3}]
	\begin{tabularx}{\textwidth}{|Z|c|Z|l|}
		\hline
		\textbf{Index} & \textbf{Default} & \textbf{Variable} & \textbf{Meaning} \\
		\hline
		- & \nxSQ{,} & ds & Default delimiter string \\
		1 & \nxSQ{:} & ks & Key separator \\
		2 & \nxSQ{\&} & als & Alias / altname separator \\
		3 & \nxSQ{@} & fas	& Appendable flag array separator \\
		4 & \nxSQ{\#} & kas	& Appendable keyword array separator \\
		5 & \nxSQ{<} & go	 & Begin group marker \\
		6 & \nxSQ{>} & gc	 & End group marker \\
		7 & \nxSQ{~~} & lo & Begin or continue long option mode \\
		8 & \nxSQ{;} & lc	 & End long option mode \\
		\hline
	\end{tabularx}
\end{NxLightBox}

\begin{NxLightListBox}[title={Short vs Long Option Group Leaders}]
		\nxEachArw{ArrowDark}{Secondary}{1}{%
			{Short form}/{Input: \nxSQ{\nxSpaces{alpha<beta gamma>}} \nxArw{2} Flags = a, l, p, h; Group leader = a; Members = b, e, t, a, gamma},%
				{Long form}/{Input: \nxSQ{\nxSpaces{ alpha<beta gamma>}} \nxArw{2} Group leader = alpha; Members = beta, gamma},%
				{Key distinction}/{Leading space (\nxSQ{lo}) preserves token as long option; without space, token explodes into flags and first flag becomes leader}%
		}
\end{NxLightListBox}

\begin{NxLightListBox}[title={Defaults for Option Groups}]
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{Group 1}/{\nxSQ{\#} keyword arrays},%
		{Group 2}/{\nxSQ{@} flag arrays},%
		{Group 3}/{\nxSQ{:} keywords},%
		{Group 4}/{\nxSQ{\nxSpaces{ }} flags},%
		{Alias Requirement}/{Each group requires one alias slot},%
		{Stride Variable}/{Denoted by $S$},%
		{Group Count}/{Denoted by $G$},%
		{Alias Slots}/{Denoted by $A$}%
	}
\end{NxLightListBox}

\nxSections{Stride mappings}{3}
\begin{NxLightListBox}[title={Variables}]
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{D1}/{Options string},%
		{go, gc}/{Group open/close markers},%
		{als}/{Alias symbol},%
		{D2}/{Runtime group stride contribution ($S_{\text{groups}}$)},%
		{strde}/{Final array stride ($S_{\text{total}}$)}%
	}
\end{NxLightListBox}

\begin{empheq}[box=\nxWarningMathBox]{align*}
	A_g &= \text{leader aliases} + \text{member aliases} \\
	S_g &= 1 + A_g \quad \text{(canonical leader slot + alias slots)} \\
	S_{\text{groups}} &= \sum_g S_g = \sum_g (1 + A_g) \\
	S_{\text{total}} &= 12 + S_{\text{groups}}
\end{empheq}
\bigskip

\begin{NxLightBox}[title={Anchors spaced by $S_{\text{total}}$}]
	\begin{tabularx}{\textwidth}{|X|Z|l|}
		\hline
		\textbf{Category} & \textbf{Base index} & \textbf{Walk by} \\
		\hline
		Keywords				 & 1	& $+\,S_{\text{total}}$ \\
		Flags						& 4	& $+\,S_{\text{total}}$ \\
		Flag arrays			& 7	& $+\,S_{\text{total}}$ \\
		Keyword arrays	 & 10 & $+\,S_{\text{total}}$ \\
		Groups (triplets)& 13 & $+\,3$ per group header, values spaced by $S_{\text{total}}$ \\
		\hline
	\end{tabularx}
\end{NxLightBox}

\nxSections{Examples}{3}

\begin{NxLightListBox}[title={Sample inputs and outputs}]
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{Input}/{\nxSQ{\nxSpaces{ alpha\\&al<beta\\&b gamma\\&g>}}},%
		{Output}/{Group leader = al; Members = b, g; Aliases = alpha, beta, gamma},%
		{Input}/{\nxSQ{\nxSpaces{ }opt1@opt2\#opt3}},%
		{Output}/{Flag array = opt1, keyword array = opt2, flag = opt3}%
	}
\end{NxLightListBox}



\nxSections{The Argument Parser}{2}

\nxSections{Option Grammar}{3}

\begin{NxLightListBox}[title={Flag semantics}]
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{-n}/{Flag true \(\langle nx:true/\rangle\)},%
		{-N}/{Flag false \(\langle nx:false/\rangle\)},%
		{\texttt{--}No}/{Alias of Not, false},%
		{\texttt{--}Not}/{Canonical flag, false}%
	}
\end{NxLightListBox}

\begin{NxLightListBox}[title={Keyword semantics}]
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{Gobble}/{Consume next token},%
		{=}/{Explicit set},%
		{= (empty)}/{Clear value},%
		{+}/{Append/push},%
		{+n}/{Repeat append n times},%
		{-}/{Pop/remove},%
		{-0}/{Global substitution (gsub)}%
	}
\end{NxLightListBox}

\begin{NxLightListBox}[title={Case polarity}]
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{Lowercase}/{Affirmative action},%
		{Uppercase}/{Opposite action}%
	}
\end{NxLightListBox}


\nxSections{Examples}{3}

\begin{NxLightListBox}[title={Sample inputs and outputs}]
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{Input}/{\nxSQ{\nxSpaces{ n\\&No\\&Not}}},%
		{Output}/{Flag = Not; Aliases = n, No; -n \nxArw{2} <nx:true/>, \texttt{--}No \nxArw{2} <nx:false/>},%
	{Input}/{\nxSQ{\nxSpaces{ key1:key2}}},%
		{Output}/{Keyword family = key1; Gobble next token as value; Alias = key2},%
	{Input}/{\nxSQ{\nxSpaces{ arr1@arr2}}},%
		{Output}/{Flag array = arr1; Keyword array = arr2},%
		{Input}/{\nxSQ{\texttt{--}value=hello}},%
		{Output}/{Keyword set; value = \nxDQ{hello}},%
		{Input}/{\nxSQ{\texttt{--}value+=world}},%
		{Output}/{Keyword append; value = previous + \nxDQ{world}},%
		{Input}/{\nxSQ{\texttt{--}value-0=foo}},%
		{Output}/{Keyword pop with gsub; remove all \nxDQ{foo} from value},%
		{Input}/{\nxSQ{\texttt{--}Flag}},%
		{Output}/{Boolean flag; uppercase \nxArw{2} <nx:false/>},%
		{Input}/{\nxSQ{\texttt{--}flag}},%
		{Output}/{Boolean flag; lowercase \nxArw{2} <nx:true/>}%
	}
\end{NxLightListBox}


\nxSections{Option Action Dispatcher}{2}

\begin{NxCodeBox}{awk}{phantomlabel={func:nx_sh_opts_pre},
	title={\textbf{Option Preprocessor Arguments}
	\begin{NxDarkList}
		\nxEachArw{CodePrimary}{Tertiary}{1}{%
			{V1}/{Argument vector (raw tokens)},%
			{V2}/{Hashmap of option values (mutable registry)},%
			{V3}/{Action descriptors (fs, fsa, fsr, separators)},%
			{D1}/{Group leader},%
			{D2}/{Alias used},%
			{D3}/{Suffix or group marker},%
			{N1}/{Category code},%
			{N2}/{Debug level},%
			{N3}/{Group index},%
			{N4}/{Current argument index}%
		}
	\end{NxDarkList}
}}
function nx_sh_opts_pre(V1, V2, V3, D1, D2, D3, N1, N2, N3, N4)
\end{NxCodeBox}

\begin{NxLightListBox}[title={Option Preprocessor — Internal Semantics}]
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{Purpose}/{Dispatch option to correct action handler based on category and operator},%
		{Mechanism}/{Resolves polarity, separators, prefixes, and invokes fsa/fsr/fs/gobble helpers},%
		{Category Behavior}/{Keyword, Flag, Flag Array, Keyword Array each adjust parameters before dispatch},%
		{Return}/{Updated argument index \(N4\)},%
		{Use Case}/{Core engine for option mutation; called once per parsed option}
	}
\end{NxLightListBox}

\begin{NxLightListBox}[title={Semantic Examples}]
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{Keyword}/{\texttt{--opt foo}, \texttt{--opt=foo}, \texttt{--opt+=foo}},%
		{Flag}/{\texttt{-f}, \texttt{--Flag}, \texttt{--Flag+=true}},%
		{Flag Array}/{\texttt{--arr foo}, \texttt{--arr+=foo}, \texttt{--arr-=foo}},%
		{Keyword Array}/{\texttt{--opt bar}, \texttt{--opt+=bar}, \texttt{--opt-=bar}}%
	}
\end{NxLightListBox}




\nxSections{Action: Push (fsa)}{3}
\begin{NxCodeBox}{awk}{phantomlabel={func:nx_sh_opts_pre_act_fsa},
	title={\textbf{Push Action Arguments (Internal Use)}
	\begin{NxDarkList}
		\nxEachArw{CodePrimary}{Tertiary}{1}{%
			{V}/{Hashmap of option values (mutable registry)},%
			{D1}/{Value to append (string)},%
			{D2}/{Separator or polarity marker},%
			{D3}/{Existing value (string)},%
			{D4}/{Option key},%
			{N1}/{Category code (1=kwd, 4=flag, 7=flag array, 10=kwd array)},%
			{N2}/{Repeat count},%
			{B}/{Case polarity (boolean sentinel)}%
		}
	\end{NxDarkList}
}}
function nx_sh_opts_pre_act_fsa(V, D1, D2, D3, D4, N1, N2, B)
\end{NxCodeBox}

\begin{NxLightListBox}[title={Push Action — Internal Semantics}]
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{Purpose}/{Append value \(D1\) to existing option \(D4\), respecting category and polarity},%
		{Mechanism}/{Flags use boolean polarity; keywords and arrays use string append via \texttt{nx\_append\_str}},%
		{Category Behavior}/{Flag \nxArw{2} boolean append; Keyword \nxArw{2} string append; Arrays \nxArw{2} separator‑aware append},%
		{Return}/{Updated registry entry \(V[D4]\)},%
		{Use Case}/{Invoked by the option preprocessor when encountering \texttt{+=} actions}
	}
\end{NxLightListBox}

\begin{NxLightListBox}[title={Semantic Examples}]
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{Keyword}/{\texttt{--}Opt+=foo \nxArw{2} enqueue \nxDQ{foo} to existing value},%
		{Flag}/{-f+ \nxArw{2} boolean append using polarity},%
		{Flag Array}/{\texttt{--}arr+=bar \nxArw{2} append \nxDQ{bar} with array separator},%
		{Keyword Array}/{\texttt{--}opt+=baz append \nxDQ{opt baz} as array element}
	}
\end{NxLightListBox}




\nxSections{Action: Pop (fsr)}{3}

\begin{NxCodeBox}{awk}{phantomlabel={func:nx_sh_opts_pre_act_fsr},
		title={\textbf{Pop Action Arguments (Internal Use)}
		\begin{NxDarkList}
				\nxEachArw{CodePrimary}{Tertiary}{1}{%
						{V}/{Hashmap of option values (mutable registry)},%
						{D1}/{Value used for pop (string)},%
						{D2}/{Separator or polarity marker},%
						{D3}/{Existing value (string)},%
						{D4}/{Option key},%
						{N1}/{Category code (1=keyword, 4=flag, 7=flag array, 10=keyword array)},%
						{N2}/{Count of removals},%
						{B}/{Case polarity (boolean sentinel)}%
				}
		\end{NxDarkList}
}}
function nx_sh_opts_pre_act_fsr(V, D1, D2, D3, D4, N1, N2, B)
\end{NxCodeBox}

\begin{NxLightListBox}[title={Pop Action — Internal Semantics}]
		\nxEachArw{ArrowDark}{Secondary}{1}{%
				{Purpose}/{Remove occurrences of \(D1\) or array elements from option \(D4\)},%
				{Mechanism}/{Keywords use \texttt{nx\_reap\_str}; arrays use \texttt{nx\_reap\_str\_match}; flags use polarity inversion},%
				{Category Behavior}/{Keyword \nxArw{2} substring pop; Flag \nxArw{2} boolean pop; Arrays \nxArw{2} element pop with separator},%
				{Return}/{Updated registry entry \(V[D4]\)},%
				{Use Case}/{Triggered when parser encounters a \texttt{-=} or \texttt{-n=} action}
		}
\end{NxLightListBox}

\begin{NxLightListBox}[title={Semantic Examples}]
		\nxEachArw{ArrowDark}{Secondary}{1}{%
			{Keyword}/{\texttt{--}Opt-=foo \nxArw{2} remove \nxDQ{foo} from value from the start},%
			{Keyword (count)}/{\texttt{--}opt-2=foo \nxArw{2} remove two occurrences from the end},%
			{Flag}/{-F- \nxArw{2} boolean pop (invert or clear)},%
			{Flag Array}/{\texttt{--}arr-=bar \nxArw{2} remove \nxDQ{bar} from array},%
			{Keyword Array}/{\texttt{--}opt-=baz \nxArw{2} remove \nxDQ{opt baz} element}
		}
\end{NxLightListBox}


\nxSections{Action: Set (fs)}{3}

\begin{NxCodeBox}{awk}{phantomlabel={func:nx_sh_opts_pre_act_fs},
	title={\textbf{Set Action Arguments (Internal Use)}
	\begin{NxDarkList}
		\nxEachArw{CodePrimary}{Tertiary}{1}{%
			{V}/{Hashmap of option values (mutable registry)},%
			{D1}/{Value to assign (string)},%
			{D2}/{Option key},%
			{N}/{Category code (1=keyword, 4=flag, 7=flag array, 10=keyword array)},%
			{B}/{Case polarity (boolean sentinel)}%
		}
	\end{NxDarkList}
}}
function nx_sh_opts_pre_act_fs(V, D1, D2, N, B)
\end{NxCodeBox}

\begin{NxLightListBox}[title={Set Action — Internal Semantics}]
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{Purpose}/{Assign value \(D1\) directly to option \(D2\)},%
		{Mechanism}/{Flags use boolean fallback when value is empty; other categories assign raw string},%
		{Category Behavior}/{Flag \nxArw{2} assign or toggle; Keyword/Arrays \nxArw{2} direct assignment},%
		{Return}/{Updated registry entry \(V[D2]\)},%
		{Use Case}/{Triggered when parser encounters a plain \texttt{=} action}
	}
\end{NxLightListBox}

\begin{NxLightListBox}[title={Semantic Examples}]
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{Keyword}/{\texttt{--opt=foo} \nxArw{2} set value to \nxDQ{foo}},%
		{Keyword (clear)}/{\texttt{--opt=} \nxArw{2} clear value},%
		{Flag}/{\texttt{--Flag=} \nxArw{2} boolean fallback based on case},%
		{Flag Array}/{\texttt{--arr=foo} \nxArw{2} replace entire array with \nxDQ{foo}},%
		{Keyword Array}/{\texttt{--opt=bar} \nxArw{2} replace array with \nxDQ{bar}}%
	}
\end{NxLightListBox}


\nxSections{Action: Gobble (no operator)}{3}

\begin{NxCodeBox}{awk}{phantomlabel={func:nx_sh_opts_pre_act},
	title={\textbf{Gobble Action Arguments (Internal Use)}
	\begin{NxDarkList}
		\nxEachArw{CodePrimary}{Tertiary}{1}{%
			{V1}/{Hashmap of option values (mutable registry)},%
			{V2}/{Argument vector (raw tokens)},%
			{D1}/{Prefix for keyword arrays},%
			{D2}/{Option key},%
			{N1}/{Category code},%
			{N2}/{Current argument index}%
		}
	\end{NxDarkList}
}}
function nx_sh_opts_pre_act(V1, V2, D1, D2, N1, N2)
\end{NxCodeBox}

\begin{NxLightListBox}[title={Gobble Action — Internal Semantics}]
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{Purpose}/{Consume the next token from the argument vector and assign it to option \(D2\)},%
		{Mechanism}/{Keyword arrays prepend their key; other categories store raw token},%
		{Category Behavior}/{Keyword \nxArw{2} gobble next token; Flag \nxArw{2} never gobbles; Arrays \nxArw{2} gobble with or without prefix},%
		{Return}/{Updated argument index \(N2\)},%
		{Use Case}/{Triggered when no operator (\texttt{=}, \texttt{+=}, \texttt{-=}) is present}
	}
\end{NxLightListBox}

\begin{NxLightListBox}[title={Semantic Examples}]
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{Keyword}/{\texttt{--opt foo} \nxArw{2} value becomes \nxDQ{foo}},%
		{Keyword Array}/{\texttt{--opt bar} \nxArw{2} value becomes \nxDQ{opt bar}},%
		{Flag}/{\texttt{-f} \nxArw{2} handled by boolean logic, not gobble},%
		{Flag Array}/{\texttt{--arr baz} \nxArw{2} append \nxDQ{baz}}%
	}
\end{NxLightListBox}







































\begin{comment}
\nxSections{Alias Resolution in Keyword Arrays}{3}
\begin{NxLightListBox}[title={Dual-Layer Behavior}]
	\nxEachArw{ArrowDark}{Secondary}{1}{%
		{Layer 1}/{Alias resolution: all aliases collapse to the last parameter in the chain},%
		{Layer 2}/{Category chaining: values accumulate under the canonical parameter slot},%
		{Outcome}/{Aliases unify multiple syntactic forms into one semantic category},%
		{Example}/{Input: \nxSQ{'A\&a@'}},%
		{Input}/{-A a -a b -A c}},%
		{Resolution}/{Output: $NEX\_K\_a = a<nx:null/>b<nx:null/>c$},%
		{Interpretation}/{Alias \nxSQ{A} resolves to canonical \nxSQ{a}, values chained into keyword array group}%
	}
\end{NxLightListBox}

\begin{empheq}[box=\nxWarningMathBox]{align*}
	\text{Alias Chain: } a \;\&\; A \;\&\; \alpha \\
	\text{Canonical Param: } a \\
	\text{Output Variable: } NEX\_K\_a \\
	\text{Values: } a<nx:null/>b<nx:null/>c
\end{empheq}




\begin{empheq}[box=\nxWarningMathBox]{align*}
								\frac{3}{4} \div \frac{2}{5}\;\nxArw{5}\;
								\frac{3}{4} \times \frac{5}{2}
\end{empheq}


\nxSections{Environment Key Conductor}{2}
\begin{NxCodeBox}{awk}{title={nx\_to\_environ(D)}}
function nx_to_environ(D, m)
{
		D = toupper(nx_trim_str(D))
		gsub(/[ \t]/, "_", D)
		if (! (m = sub(/^[.]/, "L_", D)))
		if (! (m = sub(/^[*]/, "G_", D)))
		if (! (m = sub(/^[@]/, "NEXUS_", D)))
		if (! (m = sub(/^[%]/, "P_", D)))
				sub(/^[0-9]/, "_\\&", D)
		gsub(/[^0-9A-Z_]/, "", D)
		return D
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={Environment Key Glyph — nx\_to\_environ}]
		\nxEachArw{ArrowDark}{Secondary}{1}{%
				{Purpose}/{Transforms a raw string into a valid environment variable key},%
				{Input}/{\texttt{D}: raw identifier string},%
				{Mechanism}/{Trims and uppercases string, replaces whitespace with underscores, applies prefix rules, sanitizes non-alphanumeric characters},%
				{Prefix Rules}/{\texttt{. \nxArw{2} L\_}, \texttt{* \nxArw{2} G\_}, \texttt{@ \nxArw{2} NEXUS\_}, \texttt{\% \nxArw{2} P\_}, leading digit \nxArw{2} prefixed with underscore},%
				{Return}/{Normalized environment key string},%
				{Use Case}/{Used to convert arbitrary identifiers into safe environment variable names for overlays or system exports}
		}
\end{NxLightListBox}

\begin{NxCodeBox}{awk}{title={\textbf{Convert dotted identifier}
				\begin{NxDarkList}
						\nxEachArw{CodePrimary}{Tertiary}{1}{%
								{Input}/{\texttt{".config"}},%
								{Operation}/{\texttt{nx\_to\_environ(".config")}},%
								{Expected Result}/{Returns \texttt{"L\_CONFIG"}}
						}
				\end{NxDarkList}
}}
nx_to_environ(".config")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Convert starred identifier}
				\begin{NxDarkList}
						\nxEachArw{CodePrimary}{Tertiary}{1}{%
								{Input}/{\texttt{"*global"}},%
								{Operation}/{\texttt{nx\_to\_environ("*global")}},%
								{Expected Result}/{Returns \texttt{"G\_GLOBAL"}}
						}
				\end{NxDarkList}
}}
nx_to_environ("*global")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Convert at-prefixed identifier}
				\begin{NxDarkList}
						\nxEachArw{CodePrimary}{Tertiary}{1}{%
								{Input}/{\texttt{"@path"}},%
								{Operation}/{\texttt{nx\_to\_environ("@path")}},%
								{Expected Result}/{Returns \texttt{"NEXUS\_PATH"}}
						}
				\end{NxDarkList}
}}
nx_to_environ("@path")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Convert percent-prefixed identifier}
				\begin{NxDarkList}
						\nxEachArw{CodePrimary}{Tertiary}{1}{%
								{Input}/{\texttt{"\%param"}},%
								{Operation}/{\texttt{nx\_to\_environ("\%param")}},%
								{Expected Result}/{Returns \texttt{"P\_PARAM"}}%
						}
				\end{NxDarkList}
}}
nx_to_environ("%param")
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Convert numeric-leading identifier}
				\begin{NxDarkList}
						\nxEachArw{CodePrimary}{Tertiary}{1}{%
								{Input}/{\texttt{"123abc"}},%
								{Operation}/{\texttt{nx\_to\_environ("123abc")}},%
								{Expected Result}/{Returns \texttt{"\_123ABC"}}
						}
				\end{NxDarkList}
}}
nx_to_environ("123abc")
\end{NxCodeBox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nxSections{Stringify Options Conductor}{2}
\begin{NxCodeBox}{awk}{title={\_\_nx\_stringify\_opts(V, D1, D2, D3, D4, D5, N)}}
function __nx_stringify_opts(V, D1, D2, D3, D4, D5, N, i, j)
{
		for (i in V) {
				gsub("'", "\\'", V[i])
				D1 = nx_join_str(D1,
						"NEX_" D2 "" ++j "=\x27" i "\x27 NEX_" D2 "_" i "=\x27" V[i] "\x27",
						D4)
				if (N > 2)
						nx_ansi_info("(" D3 ") " i " = " V[i] "\n")
		}
		return nx_join_str(D1, "NEX_" D2 "=\x27" trk["i"] "\x27" D5, D4)
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={Stringify Options Glyph — \_\_nx\_stringify\_opts}]
		\nxEachArw{ArrowDark}{Secondary}{1}{%
				{Purpose}/{Converts associative array \texttt{V} into environment-style option strings},%
				{Input}/{\texttt{V}: option map; \texttt{D1}: accumulator string; \texttt{D2}: option prefix; \texttt{D3}: label; \texttt{D4}: delimiter; \texttt{D5}: suffix; \texttt{N}: verbosity toggle},%
				{Mechanism}/{Iterates over \texttt{V}, escapes quotes, appends formatted \texttt{NEX\_*} assignments into \texttt{D1}, optionally prints ANSI info},%
				{Output}/{Returns concatenated string of environment-style assignments},%
				{Use Case}/{Used to serialize options into exportable environment variables for overlay systems}
		}
\end{NxLightListBox}

\begin{NxCodeBox}{awk}{title={\textbf{Serialize options with prefix "CFG"}
				\begin{NxDarkList}
						\nxEachArw{CodePrimary}{Tertiary}{1}{%
								{State}/{\texttt{V["path"]="usr/bin"}, \texttt{V["mode"]="debug"}},%
								{Operation}/{\texttt{\_\_nx\_stringify\_opts(V, "", "CFG", "opts", ";", "", 3)}},%
								{Expected Result}/{Returns string with assignments like \texttt{NEX\_CFG1='path' NEX\_CFG\_path='usr/bin'; NEX\_CFG2='mode' NEX\_CFG\_mode='debug'} and prints ANSI info}
						}
				\end{NxDarkList}
}}
__nx_stringify_opts(V, "", "CFG", "opts", ";", "", 3)
\end{NxCodeBox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\nxSections{Shell Option Arguments Conductor}{2}
\begin{NxCodeBox}{awk}{title={nx\_sh\_optargs(D1, N, D2, D3, D4)}}
function nx_sh_optargs(D1, N, D2, D3, D4,
		args, trk, stk, kwdas, kwds, grp, grps, flgs, grpa, grpas)
{
	# Check if the input string D1 is not empty
	if (D1 == "")
		return -1

	trk["ps"] = __nx_else(D2, "<nx:null/>") # Param sep
	trk["ag"] = split(D1, args, trk["ps"])
	if (N > 2)
		print args[1]

	# Define default delimiters
	trk["ds"] = __nx_else(D3, ",")
	split(D4, stk, trk["ds"])
	trk["ks"] = __nx_else(stk[1], ":") # key sep
	trk["fs"] = __nx_else(stk[2], "=") # optional flag sep
	trk["as"] = __nx_else(stk[3], "@") # appendable kwds sep

	trk["ka"] = __nx_else(stk[4], "%") # future use

	# groups
	trk["go"] = __nx_else(stk[5], "<") # begin group
	trk["gc"] = __nx_else(stk[6], ">") # eng group
	nx_bijective(trk, trk["gc"], trk["go"]) # bijective	results
	trk["gs"] = trk["go"] # initial state

	trk["lo"] = __nx_else(stk[7], "~") # begin long option
	trk["lc"] = __nx_else(stk[8], "-") # end long option
	nx_bijective(trk, trk["lc"], trk["lo"]) # bijective	results
	trk["ls"] = trk["lo"] # initial state

	trk["ln"] = split(args[1], stk, "")

	for (trk["i"] = 1;	trk["i"] <= trk["ln"]; ++trk["i"]) {
		if (nx_is_alpha(stk[trk["i"]]) && (stk[trk["i"] + 1] != trk["as"] && stk[trk["i"] + 1] != trk["go"] && stk[trk["i"] + 1] != trk["ks"])) {
			if (trk["gl"]) {
				if (trk["glj"] == 1) {
					grp[stk[trk["i"]]] = trk["gl"]
					if (N > 3)
						nx_ansi_debug("(group member added) " trk["gl"] ": " stk[trk["i"]] "\n")
				} else if (trk["glj"] == 2) {
					grpa[stk[trk["i"]]] = trk["gl"]
					if (N > 3)
						nx_ansi_debug("(group array member added) " trk["gl"] ": " stk[trk["i"]] "\n")
				} else {
					if (N > 0)
						nx_ansi_error("an overflow or a you forgot somethiing here in nex-sh!" "\n")
					D1 = -1
					break
				}
			} else {
				flgs[stk[trk["i"]]] = ""
				if (N > 3)
					print "(flag detected) " stk[trk["i"]]
			}
		} else if (stk[trk["i"]] == trk["gs"]) { # group?
			if (stk[trk["i"]] == trk["go"] && ! trk["glj"]) { # is it the begining of a group??
				trk["gl"] = stk[trk["i"] - 1] # group leader
				if (stk[trk["i"] + 1] == trk["as"]) {
					trk["i"]++
					if (N > 3)
						nx_ansi_debug("(group array toggle on) " trk["gl"] "\n")
					grpas[trk["gl"]] = ""
					trk["glj"] = 2
				} else {
					grps[trk["gl"]] = ""
					if (N > 3)
						nx_ansi_debug("(group toggle on) " trk["gl"] "\n")
					trk["glj"] = 1
				}
			} else if (trk["glj"] && stk[trk["i"]] == trk["gc"]) {
				if (N > 3) {
					if (trk["glj"] == 1)
						nx_ansi_debug("(group toggle off) " trk["gl"] "\n")
					else if (trk["glj"] == 2)
						nx_ansi_debug("(group array toggle off) " trk["gl"] "\n")
				}
				trk["gl"] = "" # unset the group leader
				trk["glj"] = 0
			} else {
				if (N > 0)
					nx_ansi_error("im not sure whats going on over here!\n")
				D1 = -1
				break
			}
			trk["gs"] = trk[trk["gs"]]
		} else if (nx_is_alpha(stk[trk["i"]])) {
			if (stk[trk["i"] + 1] == trk["ks"]) {
				if (N > 3)
					nx_ansi_debug("(key word detected) " stk[trk["i"]] "\n")
				kwds[stk[trk["i"]++]] = ""
			} else if (stk[trk["i"] + 1] == trk["as"]) {
				if (N > 3)
					nx_ansi_debug("(key word array detected) " stk[trk["i"]] "\n")
				kwdas[stk[trk["i"]++]] = ""
			}
		}
		D1 = 0
	}

	if (D1 != -1) {
		D1 = ""
		for (trk["i"] = 2; trk["i"] <= trk["ag"]; ++trk["i"]) {
			if (args[trk["i"]] == "--")
				break
			trk["ln"] = split(args[trk["i"]], stk, "")
			if (stk[1] == "-") {
				if (N > 3)
					nx_ansi_debug("(param) " args[trk["i"]] "\n")
				if (stk[2] in grpa) {
					grpas[grpa[stk[2]]] = nx_join_str(grpas[grpa[stk[2]]] , stk[2], trk["ps"])
					if (N > 3)
						nx_ansi_debug("(group array member of '" grpa[stk[2]] "') " stk[2] "\n")
				} else if (stk[2] in grp) {
					grps[grp[stk[2]]] = stk[2]
					if (N > 3)
						nx_ansi_debug("(group member of '" grp[stk[2]] "') " stk[2] "\n")
				} else if (stk[2] in flgs) {
					if (N > 3)
						nx_ansi_debug("(flag) %s: " stk[2])
					if (stk[3] == trk["fs"]) {
						flgs[stk[2]] = substr(args[trk["i"]], 4)
					} else if (trk["ln"] > 2) {
						flgs[stk[2]] = substr(args[trk["i"]], 3)
					} else {
						nx_boolean(flgs, stk[2])
					}
					if (N > 3)
						nx_ansi_print("D%\0\n" flgs[stk[2]])
				} else if (stk[2] in kwds) {
					kwds[stk[2]] = args[++trk["i"]]
					if (N > 3)
						nx_ansi_debug("(key words) " stk[2] ": " args[trk["i"]] "\n")
				} else if (stk[2] in kwdas) {
					kwdas[stk[2]] = nx_join_str(kwdas[stk[2]], args[++trk["i"]], trk["ps"])
					if (N > 3)
						nx_ansi_debug("(key word array) " stk[2] ": " kwdas[stk[2]] "\n")
				} else {
					D1 = nx_join_str(D1, args[trk["i"]], trk["ps"])
					if (N > 1)
						nx_ansi_warning("(unknown arg) " args[trk["i"]] "\n")
				}
			} else {
				D1 = nx_join_str(D1, args[trk["i"]], trk["ps"])
				if (N > 3)
					nx_ansi_debug("(remainder) " args[trk["i"]] "\n")
			}
		}

		delete grp
		if (N > 2)
			nx_ansi_info("(rmdr) " D1)
		gsub("'", "\\'", D1)
		D3 = D1
		gsub(trk["ps"], " ", D3)
		D1 = "NEX_R=\x27" D1 "\x27 \\\n NEX_S=\x27" D3 "\x27 \\\n"
		D1 = __nx_stringify_opts(kwds, D1, "k", "kwds", " ", " \\\n", N)
		D1 = __nx_stringify_opts(kwdas, D1, "K", "kwdas", " ", " \\\n", N)
		D1 = __nx_stringify_opts(grps, D1, "g", "grps", " ", " \\\n", N)
		D1 = __nx_stringify_opts(grpas, D1, "G", "grpas", " ", " \\\n", N)
		D1 = __nx_stringify_opts(flgs, D1, "f", "flgs", " ", "; # Nex is done here\n", N)
	}
	delete trk
	delete stk
	delete args
	return D1
}
\end{NxCodeBox}

\begin{NxLightListBox}[title={Shell Option Arguments Glyph — nx\_sh\_optargs}]
		\nxEachArw{ArrowDark}{Secondary}{1}{%
				{Purpose}/{Parses a shell-style argument string into flags, keywords, groups, and arrays},%
				{Input}/{\texttt{D1}: raw argument string; \texttt{N}: verbosity/debug level; \texttt{D2}: param separator; \texttt{D3}: delimiter set; \texttt{D4}: custom delimiters},%
				{Mechanism}/{Splits input into tokens, defines separators (key, flag, appendable, group, long option), detects flags, keywords, groups, arrays, and remainder args},%
				{Groups}/{Supports group toggles (\texttt{<...>}) and group arrays (\texttt{<...@>}), tracked via bijective mapping},%
				{Flags}/{Single-letter flags parsed, optional values via \texttt{=} or concatenation},%
				{Keywords}/{Key-value pairs (\texttt{k: v}) and keyword arrays (\texttt{k@ v1 v2})},%
				{Output}/{Returns environment-style string with \texttt{NEX\_*} assignments for remainder, flags, keywords, groups},%
				{Use Case}/{Used to normalize shell option parsing into structured environment variables for Nex overlay systems}
		}
\end{NxLightListBox}

\begin{NxCodeBox}{awk}{title={\textbf{Parse simple flags}
				\begin{NxDarkList}
						\nxEachArw{CodePrimary}{Tertiary}{1}{%
								{Input}/{\texttt{"-a -b"}},%
								{Operation}/{\texttt{nx\_sh\_optargs("-a -b", 3)}},%
								{Expected Result}/{Flags \texttt{a}, \texttt{b} detected, returned as \texttt{NEX\_f\_a}, \texttt{NEX\_f\_b}}
						}
				\end{NxDarkList}
}}
nx_sh_optargs("-a -b", 3)
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Parse keyword arguments}
				\begin{NxDarkList}
						\nxEachArw{CodePrimary}{Tertiary}{1}{%
								{Input}/{\texttt{"-x key:value"}},%
								{Operation}/{\texttt{nx\_sh\_optargs("-x key:value", 3)}},%
								{Expected Result}/{Keyword \texttt{key} stored with value \texttt{value}, returned as \texttt{NEX\_k\_key}}
						}
				\end{NxDarkList}
}}
nx_sh_optargs("-x key:value", 3)
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Parse grouped flags}
				\begin{NxDarkList}
						\nxEachArw{CodePrimary}{Tertiary}{1}{%
								{Input}/{\texttt{"-g a<b c>"}},%
								{Operation}/{\texttt{nx\_sh\_optargs("-g a<b c>", 3)}},%
								{Expected Result}/{Group \texttt{a} with members \texttt{c}, returned as \texttt{NEX\_g\_a}}
						}
				\end{NxDarkList}
}}
nx_sh_optargs("-g a<b c>", 3)
\end{NxCodeBox}

\begin{NxCodeBox}{awk}{title={\textbf{Parse keyword arrays}
				\begin{NxDarkList}
						\nxEachArw{CodePrimary}{Tertiary}{1}{%
								{Input}/{\texttt{"-k opt@ val1 val2"}},%
								{Operation}/{\texttt{nx\_sh\_optargs("-k opt@ val1 val2", 3)}},%
								{Expected Result}/{Keyword array \texttt{opt} with values \texttt{val1,val2}, returned as \texttt{NEX\_K\_opt}}
						}
				\end{NxDarkList}
}}
nx_sh_optargs("-k opt@ val1 val2", 3)
\end{NxCodeBox}

\begin{NxLightBox}[title={Shell Option Separators — Syntax Glyph Map}]
		\begin{tabularx}{\textwidth}{|l|X|X|}
				\hline
				\textbf{Separator} & \textbf{Role} & \textbf{Example} \\
				\hline
				\nxLnArcBox[]{:} & Key separator & key:value \nxArw{2} NEX\_k\_key='value' \\
				\hline
				\nxLnArcBox[]{=} & Flag separator &-f=value \nxArw{2} NEX\_f\_f='value' \\
				\hline
				\nxLnArcBox[]{@} & Keyword array separator & opt@ v1 v2 \nxArw{2} NEX\_K\_opt='v1,v2' \\
				\hline
				\nxLnArcBox[]{< >} & Group delimiters & a<b c> \nxArw{2} group 'a' with member 'c' \\
				\hline
		\end{tabularx}
\end{NxLightBox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{comment}
