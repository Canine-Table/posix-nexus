\newpage
\section{Math}
\label{Math}
\begin{NexMainBox}[light, hdrA, sdwA, crnA, grwB, secA]
	\begin{NexMainBox}[dark, crnA]
		The following functions provide tools for primality testing, random prime generation, and efficient computational methods for dealing with large numbers under practical constraints.
	\end{NexMainBox}
	\begin{NexMainBox}[dark, crnA]
		\begin{NexListDark}
			\NexItemDark{\NexFunction{__trim_precision(N1, N2)}: Trims \NexFunction{N2} to \NexFunction{N1} decimal places, removing trailing zeros in the fractional part.}
			\NexItemDark{\NexFunction{pi(N)}: Returns the value of $\pi$ with \NexFunction{N} decimal places of precision, using the arctangent function.}
			\NexItemDark{\NexFunction{tau(N)}: Returns the value of $\tau$ (2$\pi$) with \NexFunction{N} decimal places of precision.}
			\NexItemDark{\NexFunction{remainder(N1, N2)}: Computes the remainder when \NexFunction{N1} is divided by \NexFunction{N2}, handling precision and rounding.}
			\NexItemDark{\NexFunction{fibonacci(N, B)}: Calculates the \NexFunction{N}-th Fibonacci number, optionally displaying intermediate sums when \NexFunction{B} is true.}
			\NexItemDark{\NexFunction{factoral(N, B)}: Computes the factorial of \NexFunction{N}, optionally printing the multiplication steps when \NexFunction{B} is true.}
			\NexItemDark{\NexFunction{absolute(N)}: Returns the absolute value of \NexFunction{N}, converting negative numbers to positive.}
			\NexItemDark{\NexFunction{ceiling(N)}: Returns the smallest integer greater than or equal to \NexFunction{N}, rounding up for non-integer values.}
			\NexItemDark{\NexFunction{round(N)}: Rounds \NexFunction{N} to the nearest integer, using standard rounding rules.}
			\NexItemDark{\NexFunction{distribution(N1, N2, N3)}: Calculates the distribution value for \NexFunction{N3} within the range defined by \NexFunction{N1} and \NexFunction{N2}, rounding up to the nearest integer.}
			\NexItemDark{\NexFunction{euclidean(N1, N2)}: Implements the Euclidean algorithm to compute the greatest common divisor (GCD) of \NexFunction{N1} and \NexFunction{N2}.}
			\NexItemDark{\NexFunction{lcd(N1, N2)}: Calculates the least common multiple (LCM) of \NexFunction{N1} and \NexFunction{N2} using their GCD.}
			\NexItemDark{\NexLink{modulus_range}{modulus_range(N1, N2, N3)}: Adjusts \NexFunction{N1} to fit within the range [\NexFunction{N2}, \NexFunction{N3}] using modulus operations.}
			\NexItemDark{\NexFunction{modular_exponentiation(N1, N2, N3)}: Efficiently computes \((N1^{N2}) \bmod N3\) using iterative squaring, with \NexFunction{N3} defaulting to 100000007 if not provided.}
			\NexItemDark{\NexFunction{fermats_little_theorm(N)}: Applies Fermat's Little Theorem to estimate primality for \NexFunction{N} by checking divisibility against small primes.}
		\end{NexListDark}
	\end{NexMainBox}
\end{NexMainBox}

\begin{NexMainBox}[light, hdrA, sdwA, crnA, grwB, secB]
	\begin{NexMainBox}[dark, crnA]
		\begin{NexListDark}
			\NexItemDark{\NexFunction{divisible(N1, N2)}: Determines whether \NexFunction{N1} is divisible by \NexFunction{N2} without a remainder.}
			\NexItemDark{\NexFunction{miller_rabin(N, T, S)}: Performs the Miller-Rabin primality test on \NexFunction{N}, using \NexFunction{T} trials and separating bases with \NexFunction{S}.}
			\NexItemDark{\NexFunction{__load_primes(N, S)}: Loads a set of prime bases for testing \NexFunction{N}, selecting ranges based on the size of \NexFunction{N}, and separating them with \NexFunction{S}.}
			\NexItemDark{\NexFunction{random_prime(N)}: Generates a random prime number with up to \NexFunction{N} digits, defaulting to 8 digits due to POSIX AWK limitations.}
		\end{NexListDark}
	\end{NexMainBox}
\end{NexMainBox}

\subsection{modulus_range}
\label{modulus_range}

\begin{NexCodeBox}{bash}{title=\textbf{modulus_range(N1, N2, N3)}}
# N1: The lower bound of the range
# N2: The upper bound of the range
# N3: The modulus value to adjust the lower bound
function modulus_range(N1, N2, N3)
{
	# If N1 is less than N2, adjust N1 to be within the range [N2, N3]
	if (N1 < N2)
		N1 = N2 + (N1 - N2 + N3) % (N3 - N2 + 1)
	# If N1 is greater than N3, adjust N1 similarly
	else if (N1 > N3)
		N1 = N2 + (N1 - N2) % (N3 - N2 + 1)
	# Return the adjusted value of N1
	return N1
}
\end{NexCodeBox}

\begin{NexMainBox}[light, hdrA, sdwA, crnA, grwB, ssecB]
	\begin{NexMainBox}[dark, crnA]
		\begin{NexListDark}
			\NexItemDark{Ensures \NexFunction{N1} stays within the range [\NexFunction{N2}, \NexFunction{N3}] using modulus arithmetic.}
			\NexItemDark{If \NexFunction{N1} is less than \NexFunction{N2}, adjusts it upward by computing \NexFunction{N2 + (N1 - N2 + N3) {\%} (N3 - N2 + 1)}.}
			\NexItemDark{If \NexFunction{N1} is greater than \NexFunction{N3}, adjusts it downward by computing \NexFunction{N2 + (N1 - N2) {\%} (N3 - N2 + 1)}.}
			\NexItemDark{Returns the adjusted value of \NexFunction{N1}, ensuring it remains within bounds.}
		\end{NexListDark}
	\end{NexMainBox}
\end{NexMainBox}




