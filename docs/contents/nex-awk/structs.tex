\newpage
\section{Structures}
\label{Structures}
\begin{NexMainBox}[light, hdrA, sdwA, crnA, grwB, secA]
	\begin{NexMainBox}[dark, crnA]
		The following functions provide comprehensive utilities for creating, managing, and manipulating structured data like arrays and hashmaps, enabling efficient operations across indexed elements.
	\end{NexMainBox}
	\begin{NexMainBox}[dark, crnA]
		\begin{NexListDark}
			\NexItemDark{\NexLink{nx_find_index}{nx_find_index(\NexOption{D1}, \NexOption{S}, \NexOption{D2})}: Searches for the first occurrence of a pattern within a string, with additional constraints. Returns the index of the match or modifies behavior based on optional parameters.}
			\NexItemDark{\NexLink{nx_next_pair}{nx_next_pair(\NexOption{D1}, \NexOption{V1}, \NexOption{V2}, \NexOption{D2}, \NexOption{B1}, \NexOption{B2})}: Retrieves the next pair of start and end indices within a string (\NexOption{D1}), based on associative array delimiters (\NexOption{V1}). Outputs indices and their lengths to the result vector (\NexOption{V2}), while handling escape constraints (\NexOption{D2}). Logic flags (\NexOption{B1}, \NexOption{B2}) control fallback behavior and prioritization during evaluation.}
			\NexItemDark{\NexLink{nx_tokenize}{nx_tokenize(\NexOption{D1}, \NexOption{V1}, \NexOption{V2}, \NexOption{D2}, \NexOption{B1}, \NexOption{B2})}: Tokenizes an input string (\NexOption{D1}) based on start and end delimiters (\NexOption{V2}). Extracted tokens are stored in the output vector (\NexOption{V1}). Handles escape sequences (\NexOption{D2}) and allows prioritization or fallback using logical flags (\NexOption{B1}, \NexOption{B2}).}
		\end{NexListDark}
	\end{NexMainBox}
\end{NexMainBox}

\newpage
\subsection{nx_find_index}
\label{nx_find_index}
\begin{NexCodeBox}{bash}{title={nx_find_index(D1, S, D2)}}
function nx_find_index(D1, S, D2,	f, m)
{
	if (__nx_defined(D1, 1)) {
		f = 0
		S = __nx_else(S, " ")
		D2 = __nx_else(__nx_defined(D2, 1), "\\\\")
		while (match(D1, S)) {
			f = f + RSTART
			if (! (match(substr(D1, 1, RSTART - 1), D2 "+$") && D2) || int(RLENGTH % 2) == 0)
				break
			f = f + RLENGTH
			D1 = substr(D1, f + 1)
		}
		return f
	}
}
\end{NexCodeBox}

\begin{NexMainBox}[light, hdrA, sdwA, crnA, grwB, ssecB]
	\begin{NexMainBox}[dark, crnA]
		Searches for the first match of a given pattern (\NexOption{S}) within a string (\NexOption{D1}) while applying optional constraints (\NexOption{D2}). The function handles fallback conditions and uses nuanced logic to account for escape characters and repeated patterns.
	\end{NexMainBox}
	\begin{NexMainBox}[dark, crnA]
		\begin{NexListDark}
			\NexItemDark{\NexOption{D1}: The input string to search.}
			\NexItemDark{\NexOption{S}: The primary pattern to search for. Defaults to the space character (` `).}
			\NexItemDark{\NexOption{D2}: An optional secondary pattern used to constrain matches (e.g., escape sequences). Defaults to the backslash (`\backslash`).}
		\end{NexListDark}
	\end{NexMainBox}
\end{NexMainBox}

\begin{NexCodeBox}{bash}{title={Basic pattern matching}}
	D1 = "hell\o world"
	S = "o"
	result = nx_find_index(D1, S)
	% result is 8
	% Explanation: The first occurrence of "o" in "hello world" is excaped, the next occurence is at index 8.
\end{NexCodeBox}

\begin{NexCodeBox}{bash}{title={No match for the pattern}}
	D1 = "hello world"
	S = "z"
	result = nx_find_index(D1, S)
	% result is 0
	% Explanation: Since "z" doesn't exist in the string, the function returns 0.
\end{NexCodeBox}

\begin{NexCodeBox}{bash}{title={Default parameters}}
	D1 = "this is an example"
	result = nx_find_index(D1)
	% result is 5
	% Explanation: The default pattern `S` is a space character, and the first space is at index 5.
\end{NexCodeBox}

\begin{NexCodeBox}{bash}{title={Complex string with escape sequences}}
	D1 = "path\\to\\file"
	S = "\\\\"
	D2 = "\\\\"
	result = nx_find_index(D1, S, D2)
	% result is 5
	% Explanation: The function navigates the string while respecting escape constraints and finds the first valid match.
\end{NexCodeBox}

\newpage
\subsection{nx_next_pair}
\label{nx_next_pair}
\begin{NexCodeBox}{bash}{title={nx_next_pair(D1, V1, V2, D2, B1, B2, s, s_l, e, e_l, f, i)}}
function nx_next_pair(D1, V1, V2, D2, B1, B2, s, s_l, e, e_l, f, i) {
	if (length(V1) && D1 != "") {
		for (i in V1) {
			if ((f = nx_find_index(D1, i, D2)) && (! s || __nx_if(B2, f > s, f < s))) {
				s = f
				s_l = length(i)
				if (length(V1[i]) && (f = nx_find_index(substr(D1, s + s_l + 1), V1[i], D2))) {
					e = f
					e_l = length(V1[i])
				} else {
					e = ""
					e_l = ""
				}
			}
		}
		if (! s && B1) {
			s = length(D1) + 1
		}
		V2[++V2[0]] = s
		V2[V2[0] "_" s] = s_l
		V2[++V2[0]] = e
		V2[V2[0] "_" e] = e_l
		return V2[0] - 1
	}
}
\end{NexCodeBox}

\begin{NexMainBox}[light, hdrA, sdwA, crnA, grwB, ssecB]
	\begin{NexMainBox}[dark, crnA]
		Retrieves the next pair of start and end indices from the input string (\NexOption{D1}) based on specified delimiters (\NexOption{V1}). Stores indices and their lengths in the output vector (\NexOption{V2}) for subsequent operations. Handles escape sequences (\NexOption{D2}) and prioritizes pairs based on logical conditions (\NexOption{B1}, \NexOption{B2}).
	\end{NexMainBox}
	\begin{NexMainBox}[dark, crnA]
		\begin{NexListDark}
			\NexItemDark{\NexOption{D1}: The input string to search for start and end pairs.}
			\NexItemDark{\NexOption{V1}: An associative array mapping start delimiters (keys) to end delimiters (values).}
			\NexItemDark{\NexOption{V2}: A vector to store indices and lengths of matched pairs.}
			\NexItemDark{\NexOption{D2}: Constraints for handling escape sequences or specific delimiters.}
			\NexItemDark{\NexOption{B1}: A flag to set a fallback start index if none is found.}
			\NexItemDark{\NexOption{B2}: A logical parameter to prioritize pairs based on index comparison (above or below the previous match).}
		\end{NexListDark}
	\end{NexMainBox}
\end{NexMainBox}

\begin{NexCodeBox}{bash}{title={Matching a single pair of delimiters}}
	D1 = "<pair start content end />"
	V1["<pair start"] = "end />"
	V2[0] = 0
	result = nx_next_pair(D1, V1, V2)
	% Result:
	% V2[1] = 1, V2[1_s] = 11
	% V2[2] = 23, V2[2_e] = 6
	% Explanation: Finds the start and end delimiters, capturing their indices and lengths.
\end{NexCodeBox}

\begin{NexCodeBox}{bash}{title={Handling fallback start index}}
	D1 = "no delimiters here"
	V1["<start"] = "end />"
	V2[0] = 0
	result = nx_next_pair(D1, V1, V2, "", 1, 0)
	% Result:
	% V2[1] = 21, V2[1_s] = ""
	% V2[2] = "", V2[2_e] = ""
	% Explanation: Sets the fallback start index as the length of \NexOption{D1} + 1 since no match was found.
\end{NexCodeBox}

\begin{NexCodeBox}{bash}{title={Multiple pairs with prioritization}}
	D1 = "<startA>contentA<endA><startB>contentB<endB>"
	V1["<startA>"] = "<endA>"
	V1["<startB>"] = "<endB>"
	result = nx_next_pair(D1, V1, V2, "", 0, 1)
	% Result:
	% V2[1] = 1, V2[1_s] = 8
	% V2[2] = 20, V2[2_e] = 7
	% Explanation: Prioritizes pairs based on index comparison and logical conditions.
\end{NexCodeBox}

\newpage
\subsection{nx_tokenize}
\label{nx_tokenize}
\begin{NexCodeBox}{bash}{title={nx_tokenize(D1, V1, V2, D2, B1, B2)}}
function nx_tokenize(D1, V1, V2, D2, B1, B2, i, j, m, v, s) {
	if (length(V2) && D1 != "") {
		while (D1) {
			i = nx_next_pair(D1, V2, v, D2, 1, B1)
			m = substr(D1, v[i], v[i "_" v[i]])
			j = v[i] + v[i "_" v[i]]
			s = s substr(D1, 1, v[i] - 1)
			if (length(V2[m])) {
				s = s substr(D1, j, v[++i])
				j = j + v[i] + v[i "_" v[i]]
			} else {
				V1[++V1[0]] = s
				s = ""
			}
			D1 = substr(D1, j)
		}
		if (s != "")
			V1[++V1[0]] = s
		delete v
		return V1[0]
	}
}
\end{NexCodeBox}

\begin{NexMainBox}[light, hdrA, sdwA, crnA, grwB, ssecB]
	\begin{NexMainBox}[dark, crnA]
		Processes an input string (\NexOption{D1}) to extract and tokenize content into an output vector (\NexOption{V1}). Tokens are defined based on start and end pairs in (\NexOption{V2}). Handles constraints (\NexOption{D2}) and logical prioritization (\NexOption{B1}, \NexOption{B2}).
	\end{NexMainBox}
	\begin{NexMainBox}[dark, crnA]
		\begin{NexListDark}
			\NexItemDark{\NexOption{D1}: The input string to be tokenized.}
			\NexItemDark{\NexOption{V1}: A vector to store tokenized outputs. Each entry represents a complete token.}
			\NexItemDark{\NexOption{V2}: An associative array containing start and end delimiters for tokenization.}
			\NexItemDark{\NexOption{D2}: Constraints to handle escape sequences or special rules during tokenization.}
			\NexItemDark{\NexOption{B1}: A flag to determine logical prioritization for the next token (e.g., based on position).}
			\NexItemDark{\NexOption{B2}: A flag to control fallback behavior or logical prioritization when matching pairs.}
		\end{NexListDark}
	\end{NexMainBox}
\end{NexMainBox}

\begin{NexCodeBox}{bash}{title={Tokenizing with basic delimiters}}
	D1 = "token1, token2, token3"
	V2[""] = ","
	V1[0] = 0
	result = nx_tokenize(D1, V1, V2, "")
	% Result:
	% V1[1] = "token1"
	% V1[2] = "token2"
	% V1[3] = "token3"
	% Explanation: Tokenizes based on the delimiter "," and stores the tokens in \NexOption{V1}.
\end{NexCodeBox}

\begin{NexCodeBox}{bash}{title={Handling nested delimiters}}
	D1 = "start1(content1)end1 start2(content2)end2"
	V2["start1"] = "end1"
	V2["start2"] = "end2"
	V1[0] = 0
	result = nx_tokenize(D1, V1, V2, "")
	% Result:
	% V1[1] = "content1"
	% V1[2] = "content2"
	% Explanation: Matches "start1" with "end1" and "start2" with "end2", extracting content between them.
\end{NexCodeBox}

\begin{NexCodeBox}{bash}{title={Tokenizing with escapes}}
	D1 = "token1\,token2, token3"
	V2[""] = ","
	V1[0] = 0
	result = nx_tokenize(D1, V1, V2, "\\")
	% Result:
	% V1[1] = "token1\,token2"
	% V1[2] = "token3"
	% Explanation: Accounts for escaped commas ("\,") and ensures they are not treated as delimiters.
\end{NexCodeBox}

