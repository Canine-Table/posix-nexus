\begin{NxSSSBox}[breakable][Finite-State Automata (FSA)]
	\begin{NxIDBox}
	Finite-State Automata (FSA) are models of computation that process input using a finite number of states. They transition between states based on predefined rules and determine whether an input sequence is accepted or rejected.
	\end{NxIDBox}
	%\begin{NxIDBoxL}
	 %	 \nxTopicD{Deterministic Finite Automata (DFA)} Machines with exact state transitions for each input, ensuring predictable behavior.
	 %	 \nxTopicD{Non-Deterministic Finite Automata (NFA)} Machines that allow multiple possible transitions per input, requiring exploration of all possibilities.
	 %	 \nxTopicD{Regular Languages and FSA} Equivalence between finite-state automata and regular expressions, forming the foundation of pattern matching.
	 %	 \nxTopicD{State Transition Diagrams and Tables} Graphical and tabular representations illustrating automata behavior.
	%	 \nxTopicD{Applications of FSA} Use cases in lexical analysis, networking protocols, and hardware circuit design.
	%\end{NxIDBoxL}
\end{NxSSSBox}

\begin{NxSSSSBox}[breakable][Computation Theory: Languages]
	\begin{NxIDBox}
		In computation theory, a "language" is a set of strings formed from a given finite alphabet.
		\begin{NxListDark}
			\nxIDSTopic{Alphabet} (A finite set of symbols, e.g., \{0, 1\})
			\nxIDSTopic{Strings} (Finite sequences of symbols from the alphabet, e.g., "0", "1", "01", "10", "110", etc.)
			\nxIDSTopic{Language} (A set of valid strings, e.g., \{"0", "1", "01", "10"\})
			\nxIDSTopic{Classification} (Languages can be regular, context-free, or more complex)
			\nxIDSTopic{Theoretical Foundation} (Forms the backbone of automata theory and formal grammar)
		\end{NxListDark}
	\end{NxIDBox}
\end{NxSSSSBox}

\begin{NxSSSSBox}[breakable][Formal Language Notation]
	\begin{NxIDBox}
		Basic notation and operations in formal languages.
		\begin{NxListDark}
			\nxIDSTopic{Alphabet ($\Sigma$)} (A finite set of symbols)
			\nxIDSTopic{Exponent Notation ($\Sigma^0$)} (Represents the set of strings of length zero, including only the empty string ($\epsilon$))
			\nxIDSTopic{Brackets ($\nxLBracket \dots \nxRBracket$)} (Used to enclose the set elements)
			\nxIDSTopic{Empty Language} ($\Sigma^0 = \nxLBracket \epsilon \nxRBracket$ defines the language consisting only of the empty string)
			\nxIDSTopic{Further Construction} ($\Sigma^1$ contains all strings of length 1 (individual symbols))
			\nxIDSTopic{Kleene Star ($\Sigma^*$)} (Represents all possible finite strings formed from $\Sigma$)
			\nxIDSTopic{$L$} (A formal language consisting of strings over some alphabet $\Sigma$)
			\nxIDSTopic{$L_n$} (Subset of $L$ containing all strings of length $n$)
			\nxIDSTopic{$L^n$} (Set of all possible concatenations of $n$ strings from $L$)
			\nxIDSTopic{$L^*$} (Kleene star - Set of all finite strings formed from $L$, including $\epsilon$)
			\nxIDSTopic{$L^+$} (Similar to $L^*$ but excludes the empty string)
			\nxIDSTopic{$\Sigma^n$} (Set of all strings of length $n$ using the alphabet $\Sigma$)
			\nxIDSTopic{$\Sigma^*$} (Set of all possible finite strings using $\Sigma$ - Free monoid generated by $\Sigma$)
			\nxIDSTopic{$\Sigma^+$} (Same as $\Sigma^*$ but excluding $\epsilon$)
		\end{NxListDark}
	\end{NxIDBox}
\end{NxSSSSBox}

\begin{NxSSSSBox}[breakable][Kleene Star and Plus Notation]
	\begin{NxIDBox}
		Definitions of $\Sigma^*$ and $\Sigma^+$ in formal language theory.
		\begin{NxListDark}
			\nxIDSTopic{$\Sigma^*$} ($\{\epsilon\} \cup \{w \mid w \text{ is a string over } \Sigma\}$ - Contains all possible finite strings, including the empty string)
			\nxIDSTopic{$\Sigma^+$} ($\{w \mid w \text{ is a non-empty string over } \Sigma\}$ - Similar to $\Sigma^*$ but excludes $\epsilon$)
		\end{NxListDark}
	\end{NxIDBox}
\end{NxSSSSBox}

\begin{NxSSSSBox}[breakable][Comparison: $\Sigma^n$ vs. $L_n$]
	\begin{NxIDBox}
		Distinguishing between $\Sigma^n$, the set of all possible strings of length $n$, and $L_n$, a constrained subset within a formal language.
		\begin{NxListDark}
			\nxIDSTopic{$\Sigma^n$} (Set of all possible strings of length $n$ over alphabet $\Sigma$)
			\nxIDSTopic{Construction} (Includes every combination of symbols from $\Sigma$ that is exactly $n$ characters long)
			\nxIDSTopic{Example} (If $\Sigma = \{0,1\}$, then $\Sigma^3 = \{000, 001, 010, 011, 100, 101, 110, 111\}$)
			\nxIDSTopic{$L_n$} (Subset of formal language $L$ containing only valid strings of length $n$)
			\nxIDSTopic{Grammar Constraints} (Language $L$ follows specific rules, restricting valid strings)
			\nxIDSTopic{Example: $L_3$} (Binary strings without consecutive 1s: $L_3 = \{000, 001, 010, 100\}$)
		\end{NxListDark}
	\end{NxIDBox}
	\begin{NxIDBox}
		Key Differences
		\begin{NxListDark}
			\nxIDSTopic{Universality} ($\Sigma^n$ includes all possible strings without restriction)
			\nxIDSTopic{Constraint} ($L_n$ is defined by language rules, filtering valid strings)
			\nxIDSTopic{Kleene Star} ($\Sigma^*$ forms all finite-length strings, while $L$ is a subset satisfying specific rules)
			\nxIDSTopic{Selection} ($L$ is fixed, while $L_n$ selects its subset of length $n$)
			\nxIDSTopic{Concatenation} ($\Sigma^n$ builds length-$n$ strings by combining symbols from $\Sigma$)
		\end{NxListDark}
	\end{NxIDBox}
\end{NxSSSSBox}


\begin{NxSSSSBox}[breakable][Finite vs. Infinite Sets]
	\begin{NxIDBox}
		A finite set has a countable number of elements, while an infinite set has no upper bound.
		\begin{NxListDark}
			\nxIDSTopic{Finite Set} ($\Alpha = \{0, 01, 10, 11\}$ - Contains exactly 4 elements, so it's finite)
			\nxIDSTopic{Infinite Set} ($\Beta = \{0, 01, 00, 010, 011, 000, 0100, 0101, \dots \}$ - Keeps growing indefinitely)
			\nxIDSTopic{Countably Infinite} (Can be systematically listed, e.g., the set of all finite binary strings $\Sigma^*$)
			\nxIDSTopic{Uncountably Infinite} (Cannot be enumerated in sequence, e.g., all real numbers in the interval ($\mathbb{R}$) between 0 and 1)
		\end{NxListDark}
	\end{NxIDBox}
\end{NxSSSSBox}


$\Alpha\Beta$

\begin{NxSSSSBox}[breakable][Powers of $\Sigma$]
	\begin{NxIDBox}
		The powers of $\Sigma$ refer to sets of strings of specific lengths, built from an alphabet $\Sigma$.
		\begin{NxListDark}
			\nxIDSTopic{$\Sigma^0$} (Set containing only the empty string ($\epsilon$), length 0)
			\nxIDSTopic{$\Sigma^1$} (Set of all strings of length 1â€”the alphabet itself)
			\nxIDSTopic{$\Sigma^2$} (Set of all strings of length 2, formed by concatenating two symbols)
			\nxIDSTopic{$\Sigma^n$} (Set of all strings of length exactly $n$, constructed by taking $n$ symbols from $\Sigma$)
			\nxIDSTopic{Union of all Powers} ($\Sigma^*$ represents the set of all possible finite strings)
		\end{NxListDark}
	\end{NxIDBox}
	\begin{NxIDBox}
		Example with $\Sigma = \{0,1\}$
		\begin{NxListDark}
			\nxIDSTopic{$\Sigma^1 = \{0,1\}$} (Single-symbol strings)
			\nxIDSTopic{$\Sigma^2 = \{00, 01, 10, 11\}$} (Two-symbol combinations)
			\nxIDSTopic{$\Sigma^3 = \{000, 001, 010, 011, 100, 101, 110, 111\}$} (Three-symbol combinations)
		\end{NxListDark}
	\end{NxIDBox}
\end{NxSSSSBox}

