9. Optimization in C: Evolution Through the Years
9.1 Early Performance Considerations (Pre-1970s)
9.1.1 Manual Optimization in Assembly

9.1.1.1 Register-Based Computation for Speed

9.1.1.2 Minimizing Memory Access for Efficiency

9.1.1.3 Hardcoded Branching vs Computation Trade-offs

9.1.2 First Attempts at Algorithmic Efficiency

9.1.2.1 Sorting & Searching in Early Programming

9.1.2.2 Algorithm Complexity Awareness (O(n), O(log n))

9.2 K&R C and Low-Level Optimizations (1978 - 1989)
9.2.1 Efficient Memory Usage

9.2.1.1 Stack vs Heap Allocation Trade-offs

9.2.1.2 Using register Keyword for Speed

9.2.2 Loop Unrolling and Execution Speed

9.2.2.1 Minimizing Function Calls (inline)

9.2.2.2 Using Duff’s Device for Loop Optimization

9.3 ANSI C (1989 - 1999) – Compiler-Aided Optimization
9.3.1 Compiler Optimizations Begin

9.3.1.1 Early Optimization Flags (gcc -O1, -O2)

9.3.1.2 Understanding Instruction Pipelines

9.3.2 Memory Access Patterns

9.3.2.1 Cache-Aware Programming

9.3.2.2 Avoiding Cache Misses

9.4 C99 (1999 - 2011) – Instruction Set and SIMD Optimizations
9.4.1 CPU-Specific Optimizations

9.4.1.1 Using SIMD (#include <emmintrin.h>)

9.4.1.2 AVX-Based Performance Gains (#include <immintrin.h>)

9.4.2 Threading and Parallel Execution

9.4.2.1 Optimizing Multi-Core Execution

9.4.2.2 Lock-Free Algorithms (_Atomic)

9.5 C11 (2011 - 2018) – Modern Memory and Execution Optimization
9.5.1 Profile-Guided Optimization (PGO)

9.5.1.1 Using Real-World Data for Tuning

9.5.1.2 Compiler-Driven Optimizations

9.5.2 Cache Alignment for Peak Performance

9.5.2.1 Memory Access and Predictability

9.5.2.2 Struct Packing Strategies

9.6 C17 and Beyond – Future Optimization Techniques
9.6.1 Link-Time Optimization (LTO)

9.6.1.1 Optimizing Across Multiple Source Files

9.6.1.2 Removing Unused Functions at Compile-Time

9.6.2 The Future of Low-Level Optimization

9.6.2.1 AI-Assisted Performance Profiling

9.6.2.2 Safer High-Performance Programming

