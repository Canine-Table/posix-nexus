\begin{NxSSSBox}[breakable][x86-64]
	\begin{NxIDBox}
		x86-64 (or AMD64) is the 64-bit extension of the x86 architecture, used in modern CPUs. It improves register usage, memory management, and function calling efficiency.
		\nxGID{risc} architectures emphasize \textbf{simplified instructions}, enabling faster execution with \textbf{high instruction throughput}. They prioritize \textbf{register-heavy designs} and pipeline optimization.
	\end{NxIDBox}
	\begin{NxIDBoxL}
		\nxTopicD{Registers Overview} Registers in x86\_64 architecture are small, fast storage locations in the CPU, categorized into general-purpose, segment, and special-purpose registers for efficient computation.
		\nxTopicD{General-Purpose Registers (GPRs)} General-Purpose Registers (GPRs) are the main registers inside a CPU that store temporary data for calculations, memory operations, and program execution. They are designed to be flexible, meaning they can hold different types of valuesâ€”integers, addresses, or flagsâ€”depending on the context.
		\nxTopicD{ALU and CU} \nxGID{alu} performs all mathematical and logical operations, while the \nxGID{cu} directs the CPU by fetching, decoding, and managing instruction execution. ðŸš€
		%\nxTopicD{Function Calling Conventions} Calling conventions define how functions receive arguments and return values, with x86\_64 often using the System V ABI or Microsoft x64 convention where arguments are passed in registers before the stack is used.
		%\nxTopicD{Stack Management} The stack in x86\_64 grows downward in memory and follows a Last-In-First-Out (LIFO) principle, making it essential for function calls, local variables, and return addresses.
		%\nxTopicD{Assembly Example (C Function to Assembly)} Simple C functions getting translated into x86\_64 assembly using instructions like MOV, ADD, and RET while adhering to register conventions.
		%\nxTopicD{System Calls and Interacting with the OS} System calls in x86\_64 are typically invoked using the syscall instruction, passing parameters through specific registers to request services like file handling, process control, and memory management from the operating system.
	\end{NxIDBoxL}
\end{NxSSSBox}

\begin{NxSSSSBox}[breakable][Registers Overview]
	\begin{NxIDBox}
		Registers are small, fast storage units inside the CPU that hold data temporarily while the processor executes instructions. They are much faster than RAM because they are located directly inside the CPU and can quickly store and retrieve values needed for computations.
	\end{NxIDBox}
\end{NxSSSSBox}

\begin{NxIDBoxT}{l|p{6cm}|p{6cm}}[title={Differences Between Registers and RAM}]
	Feature & Registers & RAM (Random Access Memory) \\\hline
	Location & Inside the CPU & External, connected to the motherboard \\\hline
	Speed & Extremely fast (nanoseconds) & Slower (microseconds) \\\hline
	Size & Very small (bytes) & Large (gigabytes) \\\hline
	Purpose & Temporary storage for quick computations & Holds active programs and data \\
\end{NxIDBoxT}

\bigskip

\begin{NxSSSSBox}[breakable]
	\begin{NxIDBox}
		Registers store small bits of data for immediate use, while RAM holds larger data sets like running programs and files.
	\end{NxIDBox}
	\begin{NxIDBox}
		The x86-64 architecture supports a specific set of data storage size elements, all based on powers of two. The supported storage sizes are as follows:
	\end{NxIDBox}
	\begin{NxIDBoxT}{l|l|l|l}[title={Data Type \& NASM Directive Reference}]
		Data Type & Size (bits) & Size (bytes) & NASM Directive \\\hline
		Byte & 8 bits & 1 byte & \texttt{db} (Define Byte) \\\hline
		Word & 16 bits & 2 bytes & \texttt{dw} (Define Word) \\\hline
		Double Word & 32 bits & 4 bytes & \texttt{dd} (Define Double Word) \\\hline
		Quadword & 64 bits & 8 bytes & \texttt{dq} (Define Quad Word) \\\hline
		Double Quadword & 128 bits & 16 bytes & \texttt{dt} (Define Ten Bytes) \\
	\end{NxIDBoxT}
	\begin{NxIDBox}
		These storage sizes have a direct correlation to variable declarations in high-level languages (e.g., C, C++, Java, etc.).
	\end{NxIDBox}
	\begin{NxIDBoxT}{l|l|l}[title={C/C++ Declaration Storage Size}]
		Declaration & Storage Size (bits) & Storage Size (bytes) \\\hline
		char & Byte & 8-bits & 1 byte \\\hline
		short & Word & 16-bits & 2 bytes \\\hline
		int & Double-word & 32-bits & 4 bytes \\\hline
		unsigned int & Double-word & 32-bits & 4 bytes \\\hline
		long5 & Quadword & 64-bits & 8 bytes \\\hline
		long long & Quadword & 64-bits & 8 bytes \\\hline
		char * & Quadword & 64-bits & 8 bytes \\\hline
		int * & Quadword & 64-bits & 8 bytes \\\hline
		float & Double-word & 32-bits & 4 bytes \\\hline
		double & Quadword & 64-bits & 8 bytes \\
	\end{NxIDBoxT}
\end{NxSSSSBox}

\begin{NxSSSSBox}[breakable][General Purpose Registers (GPRs)]
	\begin{NxIDBoxT}{l|l|l|l}
		64-bit Register & Lowest 32-bits & Lowest 16-bits & Lowest 8-bits \\\hline
		rax & eax & ax & al \\\hline
		rbx & ebx & bx & bl \\\hline
		rcx & ecx & cx & cl \\\hline
		rdx & edx & dx & dl \\\hline
		rsi & esi & si & sil \\\hline
		rdi & edi & di & dil \\\hline
		rbp & ebp & bp & bpl \\\hline
		rsp & esp & sp & spl \\\hline
		r8  & r8d  & r8w  & r8b \\\hline
		r9  & r9d  & r9w  & r9b \\\hline
		r10 & r10d & r10w & r10b \\\hline
		r11 & r11d & r11w & r11b \\\hline
		r12 & r12d & r12w & r12b \\\hline
		r13 & r13d & r13w & r13b \\\hline
		r14 & r14d & r14w & r14b \\\hline
		r15 & r15d & r15w & r15b \\
	\end{NxIDBoxT}
\end{NxSSSSBox}

\bigskip

\begin{NxSSSSBox}[breakable]
	\begin{NxIDBoxT}{l|l}[title={Syscall Register Usage}]
		Register & Purpose \\\hline
		rax & Syscall number (which syscall to execute) \\\hline
		rdi & First argument to the syscall \\\hline
		rsi & Second argument \\\hline
		rdx & Third argument \\\hline
		r10 & Fourth argument \\\hline
		r8 & Fifth argument \\\hline
		r9 & Sixth argument \\
	\end{NxIDBoxT}
\end{NxSSSSBox}

\begin{NxSSSSBox}[breakable]
	\begin{NxIDBox}[title={Stack Pointer Register (RSP) in x86-64}]
		The Stack Pointer (RSP) is a critical register in x86-64 architecture that tracks the top of the stack in memory. It plays a key role in function calls, local variables, and memory management.
		\begin{NxListDark}
			\nxIDSTopic{Stack Management} (Points to the top of the stack, storing temporary values)
			\nxIDSTopic{Automatic Updates} (Adjusts dynamically when pushing or popping data)
			\nxIDSTopic{Function Calls} (Stores return addresses and parameters during function execution)
		\end{NxListDark}
	\end{NxIDBox}
\end{NxSSSSBox}

\begin{NxSSSSBox}[breakable]
	\begin{NxIDBox}[title={Base Pointer Register (RBP) in x86-64}]
		The Base Pointer (RBP) is a register that serves as a stable reference point for the stack in x86-64 assembly. It helps manage function stack frames, ensuring consistent access to local variables and function parameters.
		\begin{NxListDark}
			\nxIDSTopic{Fixed Reference} (Stays constant within a function, unlike RSP)
			\nxIDSTopic{Parameter \nxAnd Variable Access} (Ensures reliable stack-based memory operations)
			\nxIDSTopic{Debugging \nxAnd Stack Tracing} (Used by compilers to structure stack frames)
		\end{NxListDark}
	\end{NxIDBox}
\end{NxSSSSBox}

\begin{NxSSSSBox}[breakable]
	\begin{NxIDBox}[title={Instruction Pointer Register (RIP) in x86-64 (ELF64)}]
		The RIP register is the Instruction Pointer in x86-64. It tracks the address of the next instruction to be executed in a program.
		\begin{NxListDark}
			\nxIDSTopic{Instruction Addressing} (Holds the memory address of the next instruction)
			\nxIDSTopic{Automatic Increment} (Advances as instructions execute)
			\nxIDSTopic{Relative Addressing} (Allows access to nearby data without absolute addresses)
		\end{NxListDark}
	\end{NxIDBox}
\end{NxSSSSBox}

\begin{NxSSSSBox}[breakable]
	\begin{NxIDBox}[title={Flag Register (RFLAGS) in x86-64 (ELF64)}]
		The RFLAGS register (formerly EFLAGS in x86) is a special-purpose register in x86-64 that stores the status of the CPU after executing instructions. It contains various flags that control operations, handle conditions, and influence program flow.
	\end{NxIDBox}
	\begin{NxIDBoxT}{l|l|l|p{7cm}}[title={CPU Flags}]
		Name & Symbol & Bit & Use \\\hline
		Carry & CF & 0 & Used to indicate if the previous operation resulted in a carry. \\\hline
		Parity & PF & 2 & Used to indicate if the last byte has an even number of 1's (i.e., even parity). \\\hline
		Adjust & AF & 4 & Used to support Binary Coded Decimal operations. \\\hline
		Zero & ZF & 6 & Used to indicate if the previous operation resulted in a zero result. \\\hline
		Sign & SF & 7 & Used to indicate if the result of the previous operation resulted in a 1 in the most significant bit (indicating negative in the context of signed data). \\\hline
		Direction & DF & 10 & Used to specify the direction (increment or decrement) for some string operations. \\\hline
		Overflow & OF & 11 & Used to indicate if the previous operation resulted in an overflow. \\
	\end{NxIDBoxT}
\end{NxSSSSBox}

\begin{NxSSSSBox}[breakable]
	\begin{NxIDBox}[title={XMM Registers in x86-64 (ELF64)}]
		The XMM registers are a set of 128-bit registers used in SSE (Streaming SIMD Extensions) instructions for efficient vectorized processing in x86-64 architecture. These registers allow parallel execution of multiple floating-point or integer operations, making them essential for high-performance computing, multimedia processing, and optimized mathematical calculations.
	\end{NxIDBox}
	\begin{NxIDBox}
		Each 128-bit XMM register can store various data types for efficient SIMD operations.
		\begin{NxListDark}
			\nxIDSTopic{Single-Precision Floats} (Stores four 32-bit float values)
			\nxIDSTopic{Double-Precision Floats} (Stores two 64-bit double values)
			\nxIDSTopic{Packed Integers} (Supports 8-bit, 16-bit, or 32-bit integer values)
		\end{NxListDark}
	\end{NxIDBox}
	\begin{NxIDBoxT}{l|l}[title={Overview of XMM Registers}]
		Register & Purpose\\\hline
		XMM0-XMM7 & Standard XMM registers (used in 32-bit and 64-bit modes)\\\hline
		XMM8-XMM15 & Additional XMM registers (available only in x86-64 mode)\\
	\end{NxIDBoxT}
\end{NxSSSSBox}

\begin{NxCodeBox}{c}{dark, sdwA, frmE, title={Hereâ€™s how different variables are stored in memory based on their declaration}}
	#include <stdio.h>
	#include <stdlib.h>

	/* Stored in BSS (Uninitialized Global) */
	int uninitialized_global;

	// Stored in Data Segment (Initialized Global) */
	int initialized_global = 42;

	int main() {
		/* Stored in Stack (Local Variable) */
		int local_variable = 7;

		/* Stored in Heap (Dynamically Allocated) */
		int *heap_variable = (int*)malloc(sizeof(int));
		*heap_variable = 99; /* Assign value */

		printf("Local Variable: %d\n", local_variable);
		printf("Global Initialized Variable: %d\n", initialized_global);
		printf("Heap Variable: %d\n", *heap_variable);

		/* Free allocated memory */
		free(heap_variable);

		return 0;
	}
\end{NxCodeBox}

\begin{NxSSSSBox}[breakable]
	\begin{NxIDBoxT}{l|l|l}[title={Memory Storage Classification}]
		Variable Type & Example & Stored in \\\hline
		Uninitialized Global & \texttt{int uninitialized\_global;} & BSS Segment \\\hline
		Initialized Global & \texttt{int initialized\_global = 42;} & Data Segment \\\hline
		Local Variable & \texttt{int local\_variable = 7;} & Stack \\\hline
		Dynamically Allocated & \texttt{int *heap\_variable = (int*)malloc(sizeof(int));} & Heap \\\hline
		Code Instructions & \texttt{main() \{ ... \}} & Text Segment \\
	\end{NxIDBoxT}
\end{NxSSSSBox}

\begin{NxCodeBox}{asm}{dark, sdwA, frmE, title={When calling malloc, we use syscall 9 (mmap) to allocate memory}}
	section .text
	global _start

	_start:
		mov rax, 9		 ; syscall: mmap (alloc memory)
		mov rdi, 0		 ; NULL (any available address)
		mov rsi, 4096	  ; Allocate 4KB (example)
		mov rdx, 3		 ; PROT_READ | PROT_WRITE
		mov r10, 0x22	  ; MAP_PRIVATE | MAP_ANONYMOUS
		mov r8, -1		 ; No file backing
		mov r9, 0		  ; Offset
		syscall			; Invoke mmap (returns address)

		; Store returned heap address in rbx
		mov rbx, rax	   

		mov rax, 60		; syscall: exit
		xor rdi, rdi	   ; exit code 0
		syscall
\end{NxCodeBox}

\begin{comment}
Memory Unit Example Size Typical Speed
Registers 16, 64-bit registers ~1 nanoseconds13
Cache Memory 4 - 8+ Megabytes14
(L1 and L2)
~5-60 nanoseconds
Primary Storage
 (i.e., main memory)
2 â€“ 32+ Gigabytes15 ~100-150 nanoseconds
Secondary Storage
 (i.e., disk, SSD's, etc.)
500 Gigabytes â€“
 4+ Terabytes16
~3-15 milliseconds
\end{comment}

\begin{NxSSSSBox}[breakable]
	\begin{NxIDBox}
		The ALU (Arithmetic Logic Unit) and CU (Control Unit) work together to process instructions inside the CPU.
	\end{NxIDBox}
	\begin{NxIDBox}
		The Control Unit (CU) oversees instruction execution and communication with the Arithmetic Logic Unit (ALU).
		\begin{NxListDark}
			\nxIDSTopic{Fetch} (Retrieves instruction from memory)
			\nxIDSTopic{Decode} (Interprets the instruction and determines actions)
			\nxIDSTopic{Control Signals} (CU directs signals to ALU for execution)
			\nxIDSTopic{Execution} (ALU performs arithmetic or logic operations)
			\nxIDSTopic{Storage} (Result is stored in a register or memory)
			\nxIDSTopic{Next Instruction} (CU advances to maintain execution flow)
		\end{NxListDark}
	\end{NxIDBox}
\end{NxSSSSBox}

\begin{comment}
\begin{NxCodeBox}{asm}{dark, sdwA, frmE, title={
}}

\end{NxCodeBox}

\bigskip
\end{comment}
