#nx_include nex-constant.bc
#nx_include nex-calculus.bc
#nx_include nex-misc.bc

##################################################################

define nx_squares(x) {
	auto a, s, b, y
	a = nx_abs(x)
	if (a == 0 || scale == 0)
		return x
	s = 1
	while (s < a)
		s = s * 2
	b = nx_scale(1)
	x = 0
	y = 0
	while (s > b) {
		if (s <= a) {
			a = a - s
			x = y
			y = nx_nr_sqrt(s)
			if (y == -1)
				return x
			if (x != 0)
				print x, ","
		}
		s = s / 2
	}
	return y
}

# y == 0 => trunc
# y == 1 => floor
# y == 2 => ceil
# y == 3 => round
# y == 4 => decimal
# y == 5 => unround
define nx_part(x, y) {
	auto t, s, n
	n = nx_abs(x)
	if (n == 0 || scale == 0)
		return x
	s = 1
	while (s < n)
		s = s * 2
	t = 0
	while (s > 0.9) {
		if (s <= n) {
			n = n - s
			t = t + s
			if (n == 0)
				s = 1
		}
		s = s / 2
	}
	if (x < 0) {
		s = -n
		x = 0
	} else {
		s = n
		x = 1
	}
	if (y == 4) {
		t = n
		s = 0
	} else if (y == 0) {
		s = 0
	} else if (n != 0) {
		if (y == 1 && x == 0) { # floor
			s = -1
		} else if (y == 2 && x == 1) { # ceil
			s = 1
		} else if ((y == 3 || y == 5) && (s > 0.4 ||s < -0.5)) { # round
			s = nx_sign(s)
			if (y == 5)
				s = -s
		} else { # trunc
			s = 0
		}
	}
	if (x == 0)
		return -t + s
	return t + s
}

##################################################################
define nx_abs(x) {
	if (x < 0)
		return -x
	return x
}

##################################################################

define nx_pt_unround(x) {
	return nx_part(x, 5)
}

define nx_pt_frac(x) {
	return nx_part(x, 4)
}

define nx_pt_round(x) {
	return nx_part(x, 3)
}

define nx_pt_ceil(x) {
	return nx_part(x, 2)
}

define nx_pt_floor(x) {
	return nx_part(x, 1)
}

define nx_pt_trunc(x) {
	return nx_part(x, 0)
}

##################################################################

define nx_pow(x, y) {
	auto n
	if (y == 0)
		return 1
	n = x
	while (y-- > 1) {
		n = n * x
	}
	return n
}

define nx_erde_pow(x, y) {
	if (x <= 0) {
		print "<nx:impurity/>"
		return -1
	}
	if (y != nx_pt_floor(y))
		return nx_er_exp(y * nx_de_ln(x))
	return nx_pow(x, y)
}

##################################################################
define nx_nr_sqrt(x) {
	auto y, p
	if (nx_xy_breach(x, 1) == -1)
		return -1
	y = x / 2
	p = 0
	while (y != p) {
		p = y
		y = (y + x / y) / 2
	}
	return y
}

##################################################################
define nx_sum(x, y) {
	auto i
	if (y == 0)
		return x
	i = y
	while (x > i)
		y += x--
	return y
}

##################################################################
define nx_er_exp(x) {
	auto n, m, r
	n = 1
	m = 1
	while (m != r) {
		r = m
		m = m + x ^ n / nx_fact(n)
		n++
	}
	return m
}

##################################################################
define nx_euc(x, y) {
	auto n
	if (x == y)
		return x
	while (x > 0 && y > 0) {
		n = x
		x = nx_pt_mod(y, x)
		y = n
	}
	return n
}

define nx_lcd(x, y) {
	return x * y / nx_euc(x, y)
}

##################################################################
define nx_binom(x, y) {
	auto n
	if (nx_xy_breach(x, y) == -1)
		return -1
	if (nx_abs(y) == 0 || x == y)
		return 1
	n = 1
	for (i = 1; i <= y; ++i)
		n = n * (x - i + 1) / i
	return n
}

define nx_binom_fact(x, y) {
	if (nx_xy_breach(x, y) == -1)
		return -1
	return nx_fact(x) / (nx_fact(y) * nx_fact(x - y))
}

##################################################################
define nx_scale(x) {
	if (x == 1)
		return 1 / ibase ^ scale
	if (x == 3)
		return 1 / obase ^ scale
	if (x == 4)
		return obase ^ scale
	return ibase ^ scale
}

##################################################################
define nx_pt_mod(x, y) {
	x = nx_abs(x)
	if (x == 0)
		return 0
	y = nx_abs(y)
	if (y > 0)
		return x - y * nx_pt_trunc(x / y)
	print "<nx:impurity/>"
	return -1
}

##################################################################
define nx_sign(x) {
	if (x < 0)
		return -1
	if (x > 0)
		return 1
	return 0
}

##################################################################





